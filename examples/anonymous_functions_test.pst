// Test anonymous functions and type deduction
fn main() -> void {
    // Test anonymous function with explicit types
    let add = (int x, int y) -> int {
        return x + y;
    };
    print(add(5, 3));  // Should print 8

    // Test anonymous function with type deduction
    let multiply = (int x, int y) -> int {
        return x * y;
    };
    print(multiply(4, 6));  // Should print 24

    // Test function with fn keyword and type deduction
    fn<int> calculate(int x, int y) {
        return x * y + x;
    }
    print(calculate(3, 4));  // Should print 15

    // Test nested anonymous functions
    let outer = (int x) -> int {
        let inner = (int y) -> int {
            return x + y;  // Captures x from outer scope
        };
        return inner(10);
    };
    print(outer(5));  // Should print 15

    // Test type checking with explicit return type
    let divide = (float x, float y) -> float {
        return x / y;
    };
    print(divide(10.0, 2.0));  // Should print 5.0

    // Test higher-order function
    let apply = (fn<int>(int) func, int x) -> int {
        return func(x);
    };

    let double = (int x) -> int {
        return x * 2;
    };

    // Test passing lambda to higher-order function
    print(apply(double, 5));  // Should print 10

    // Test immediate lambda invocation
    print(((int x) -> int { return x * 3; })(4));  // Should print 12

    // Test lambda with multiple statements
    let complex = (int x) -> int {
        let temp = x * 2;
        if (temp > 10) {
            return temp + 5;
        }
        return temp;
    };
    print(complex(4));   // Should print 8
    print(complex(6));   // Should print 17

    return;
}
