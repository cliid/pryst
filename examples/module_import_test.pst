// Example of module imports and usage
import pryst::web;
import pryst::net::http;  // Test nested module import

fn main() -> int {
    // Test direct module access
    print("Host: " + web::host());
    let port = web::port();
    print("Port: " + port.toString());

    // Test server start/stop with qualified names
    if (web::start()) {
        print("Server started successfully");
        web::stop();
    }

    // Test nested module access
    let client = http::Client();
    print("HTTP Version: " + http::version());

    // Test block-level using declarations
    {
        using module web;
        print("Using module - Host: " + host());
        let port2 = port();
        print("Using module - Port: " + port2.toString());

        // Nested block with different using declaration
        {
            using module http;
            let response = get("http://localhost:" + port2.toString());
            print("Response: " + response.status().toString());
        }

        // Previous using module web should still be in effect
        print("Still using web module: " + host());
    }

    // Test using namespace declaration
    using namespace pryst;
    web::start();  // Access through namespace
    http::post("http://localhost:" + web::port().toString(), "test");
    web::stop();

    // Test error handling for missing modules
    try {
        import pryst::nonexistent;
    } catch (error) {
        print("Caught expected error: " + error.message());
    }

    // Test multiple using declarations in same block
    {
        using module web;
        using module http;
        start();  // from web
        let response = get("http://localhost:" + port().toString());  // from http
        stop();   // from web
    }

    return 0;
}

// Test module resolution in function parameters
fn processRequest(web::Request req, http::Response res) -> void {
    print("Processing request to: " + req.url());
    res.send("Hello from Pryst!");
}
