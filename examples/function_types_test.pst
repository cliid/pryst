// Test function types and anonymous functions
fn main() -> void {
    // Test anonymous function with basic syntax
    let add = (int x, int y) -> int {
        return x + y;
    };
    print(add(5, 3));  // Should print 8

    // Test function type in parameter
    fn apply(fn<int>(int, int) func, int x, int y) -> int {
        return func(x, y);
    }

    // Test passing anonymous function as argument
    let result = apply((int a, int b) -> int {
        return a * b;
    }, 4, 5);
    print(result);  // Should print 20

    // Test function type as variable
    let divide = (float x, float y) -> float {
        return x / y;
    };
    print(divide(10.0, 2.0));  // Should print 5.0

    // Test higher-order function returning function
    fn makeMultiplier(int factor) -> fn<int>(int) {
        return (int x) -> int {
            return x * factor;
        };
    }

    let double = makeMultiplier(2);
    print(double(5));  // Should print 10

    // Test nested function types
    let compose = (fn<int>(int) f) -> fn<int>(int) {
        return (int x) -> int {
            return f(f(x));
        };
    };

    let addOne = (int x) -> int {
        return x + 1;
    };

    let addTwo = compose(addOne);
    print(addTwo(5));  // Should print 7

    // Test block-scoped function declaration
    {
        fn localFunc(int x) -> int {
            return x * x;
        }
        print(localFunc(4));  // Should print 16
    }

    // Test function type with multiple return statements
    let max = (int x, int y) -> int {
        if (x > y) {
            return x;
        }
        return y;
    };
    print(max(8, 3));  // Should print 8

    // Test function type with void return
    let printTwice = (int x) -> void {
        print(x);
        print(x);
    };
    printTwice(42);  // Should print 42 twice

    // Test function type with type casting
    let convertAndMultiply = (float x) -> int {
        return (int)(x * 2.5);
    };
    print(convertAndMultiply(4.2));  // Should print 10

    // Test nested functions with captures
    fn createCounter(int start) -> fn<int>() {
        let count = start;
        return () -> int {
            count = count + 1;
            return count;
        };
    }

    let counter = createCounter(0);
    print(counter());  // Should print 1
    print(counter());  // Should print 2

    return;
}
