// Test function type deduction
fn add(int x, int y) {
    return x + y;  // Should deduce int
}

fn addFloat(float x, float y) {
    if (x > y) {
        return x + y;  // Should deduce float
    }
    return y + x;  // Multiple returns of same type
}

fn mixed(int x, float y) {
    return x + y;  // Should deduce float due to promotion
}

// Test explicit return type
int explicit_return(int x) {
    return x;  // Must match int
}

// Test type conversion
fn conversion_test() {
    let x = 42;
    let s1 = str(x);      // Using typeName(expr)
    let s2 = (str) x;     // Using (typeName) expr
    let f1 = float(x);    // int to float
    let i1 = int(f1);     // float to int

    print(s1);
    print(s2);
    print(f1);
    print(i1);
}

// Test function type syntax
fn higher_order(fn<int>(int, int) func, int x, int y) -> int {
    return func(x, y);
}

// Test class conversion
class Point {
    float x;
    float y;

    static fn c!Point(str coords) -> Point {
        // Convert "x,y" string to Point
        let parts = coords.split(",");
        let point = new Point();
        point.x = float(parts[0]);
        point.y = float(parts[1]);
        return point;
    }

    fn toString() -> str {
        return "(" + str(this.x) + ", " + str(this.y) + ")";
    }
}

fn main() -> void {
    // Test basic type deduction
    let x = 42;              // Should deduce int
    let y = 3.14;           // Should deduce float
    let z = "hello";        // Should deduce str
    let b = true;           // Should deduce bool

    // Test arithmetic type promotion
    let sum = x + y;        // Should promote x to float
    print(sum);             // Should print 45.14

    // Test function calls with type deduction
    print(add(5, 3));       // Should print 8
    print(addFloat(2.5, 3.7));  // Should print 6.2
    print(mixed(1, 2.5));   // Should print 3.5
    print(explicit_return(10));  // Should print 10

    // Test type conversions
    conversion_test();

    // Test lambda with type deduction
    let add_func = (int x, int y) -> int { return x + y; };
    print(higher_order(add_func, 10, 20));  // Should print 30

    // Test class conversion and toString
    let point = Point("1.5,2.5");
    print(point.toString());  // Should print "(1.5, 2.5)"

    // Test nested function type deduction
    let outer = (int x) -> fn<int>(int) {
        return (int y) -> int {
            return x + y;   // Captures x from outer scope
        };
    };
    let inner = outer(5);
    print(inner(3));        // Should print 8

    // Test string interpolation with type deduction
    let name = "Alice";
    let age = 30;
    print("Name: {name}, Age: {age}");  // Should print "Name: Alice, Age: 30"

    // Test type conversion in string interpolation
    let height = 5.8;
    print("Height: {height:.1f} ft");  // Should print "Height: 5.8 ft"

    // Test const type inference
    const PI = 3.14159;     // Should be float
    const MSG = "Hello";    // Should be str
    print(PI);              // Should print 3.14159
    print(MSG);             // Should print "Hello"

    return;
}
