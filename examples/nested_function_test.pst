// Comprehensive test of nested functions in Pryst

// Test class with nested functions and variable capture
class TestClass {
    let value: int = 42;

    fn method() -> void {
        let outer_val = 10;

        // Named nested function with variable capture
        let printMsg = (str msg) -> void {
            print(msg + " (class value: " + value.toString() + ", outer value: " + outer_val.toString() + ")");
        };

        // Anonymous nested function with variable capture
        let printer = (str msg) -> void {
            let inner_val = 20;
            print(msg + " (inner value: " + inner_val.toString() + ")");

            // Deeply nested function with multiple captures
            let deepPrinter = () -> void {
                print("Deep print - class: " + value.toString() +
                      ", outer: " + outer_val.toString() +
                      ", inner: " + inner_val.toString());
            };
            deepPrinter();
        };

        // Test both functions
        printMsg("Hello from named nested function");
        printer("Hello from anonymous nested function");

        // Test block scope and nested function declaration
        {
            let block_val = 30;
            let deeplyNested = () -> void {
                print("Block value: " + block_val.toString() +
                      ", outer value: " + outer_val.toString() +
                      ", class value: " + value.toString());
            };
            deeplyNested();
        }
    }

    // Test nested function with return value and type inference
    fn calculate() -> int {
        let multiplier = 2;

        // Nested function with type inference
        let multiply = (int x) -> int {
            return x * multiplier;
        };

        // Another nested function using the first one
        let addAndMultiply = (int x, int y) -> int {
            return multiply(x + y);
        };

        return addAndMultiply(value, 10);  // Should return (42 + 10) * 2
    }
}

// Test nested functions in global scope
fn outer(int x) -> int {
    let outer_val = x * 2;

    // Nested function with capture
    let inner = (int y) -> int {
        return outer_val + y;
    };

    // Test nested function type inference
    let compute = (int z) -> int {
        return inner(z) * x;
    };

    return compute(5);  // Should return ((x * 2) + 5) * x
}

fn main() -> void {
    let test = new TestClass();
    test.method();

    print("Calculation result: " + test.calculate().toString());

    let result = outer(3);
    print("Outer function result: " + result.toString());  // Should print ((3 * 2) + 5) * 3 = 33
}
