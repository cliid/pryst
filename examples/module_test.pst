// Example of module imports and usage in Pryst

// Import the web module
import pryst::web;
import pryst::net::http;  // Test nested module import

// Example using direct module access
fn test_direct() -> void {
    print("Testing direct module access");
    print("Host: " + web::host());      // Should print "localhost"
    print("Port: " + web::port().toString());  // Should print 8080
    web::start();       // Should print starting message
    web::stop();        // Should print stopping message

    // Test nested module access
    let client = http::Client();
    print("HTTP Version: " + http::version());
}

// Example using 'using module' declaration
fn test_using_module() -> void {
    print("\nTesting using module declaration");
    {
        using module web;
        print("Host: " + host());      // Should print "localhost"
        print("Port: " + port().toString());  // Should print 8080
        start();           // Should print starting message
        stop();            // Should print stopping message

        // Nested block with different using declaration
        {
            using module http;
            let response = get("http://localhost:" + port().toString());
            print("Response: " + response.status().toString());
        }

        // Previous using module web should still be in effect
        print("Still using web module: " + host());
    }

    // Outside block - should require qualified names
    print("Outside block - using qualified name: " + web::host());
}

// Example using namespace
namespace networking {
    module tcp {
        fn connect(str host, int port) -> bool {
            let msg = "Connecting to ";
            let port_str = str(port);
            print(msg + host + ":" + port_str);
            return true;
        }

        fn disconnect() -> void {
            print("Disconnecting TCP connection");
        }
    }
}

// Example using namespace import
fn test_namespace() -> void {
    using namespace networking;
    print("\nTesting namespace import");
    let result = tcp::connect(web::host(), web::port());
    print("Connection status: " + result.toString());
    tcp::disconnect();

    // Test error handling for missing modules
    try {
        import pryst::nonexistent;
    } catch (error) {
        print("Caught expected error: " + error.message());
    }
}

// Test module resolution in function parameters
fn process_request(web::Request req, http::Response res) -> void {
    print("Processing request to: " + req.url());
    res.send("Hello from Pryst!");
}

// Main function to test all approaches
fn main() -> void {
    test_direct();
    test_using_module();
    test_namespace();

    // Test block-level using declarations
    {
        using module web;
        using module http;
        start();  // from web
        let response = get("http://localhost:" + port().toString());  // from http
        stop();   // from web
    }
}
