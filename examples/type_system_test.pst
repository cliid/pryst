// Test type conversion expressions
fn test_type_conversions() {
    // Test int to string conversion using both syntaxes
    let x = 42;
    let s1 = str(x);        // type(expr) syntax
    let s2 = (str) x;       // (type) expr syntax
    print(s1);              // Should print "42"
    print(s2);              // Should print "42"

    // Test float to string conversion
    let f = 3.14;
    let s3 = str(f);        // type(expr) syntax
    let s4 = (str) f;       // (type) expr syntax
    print(s3);              // Should print "3.14"
    print(s4);              // Should print "3.14"

    // Test string to int conversion
    let numStr = "123";
    let i1 = int(numStr);   // type(expr) syntax
    let i2 = (int) numStr;  // (type) expr syntax
    print(i1);              // Should print 123
    print(i2);              // Should print 123

    // Test string to float conversion
    let floatStr = "3.14";
    let f1 = float(floatStr);   // type(expr) syntax
    let f2 = (float) floatStr;  // (type) expr syntax
    print(f1);              // Should print 3.14
    print(f2);              // Should print 3.14

    // Test int to float conversion
    let i = 42;
    let f3 = float(i);      // type(expr) syntax
    let f4 = (float) i;     // (type) expr syntax
    print(f3);              // Should print 42.0
    print(f4);              // Should print 42.0

    // Test implicit type promotions
    let intVal = 42;
    let floatVal = 3.14;
    let sum = intVal + floatVal;  // int promoted to float
    print(sum);             // Should print 45.14

    // Test explicit type declarations
    let explicit_int: int = 42;
    let explicit_float: float = 3.14;
    let explicit_str: str = "hello";
    let explicit_bool: bool = true;
    print(explicit_int);
    print(explicit_float);
    print(explicit_str);
    print(explicit_bool);

    // Test type safety violations (should cause compile-time errors)
    // let invalid1: int = "not an int";     // Type mismatch error
    // let invalid2: float = true;           // Type mismatch error
    // let invalid3 = 42 + "string";         // Invalid operation error
    // let invalid4: bool = 42;              // Type mismatch error
}

// Test function type syntax and return type checking
fn explicit_return_type(int x) -> int {
    return x * 2;           // Valid: returns int
}

fn implicit_return_type(int x) {
    return x * 2;           // Type deduced as int
}

fn mixed_returns(int x) -> float {
    if (x > 0) {
        return float(x);    // Returns float
    } else {
        return 3.14;        // Returns float
    }
}

// Test anonymous functions with type deduction
fn test_anonymous_functions() {
    // Anonymous function with explicit parameter types
    let double = (int x) -> int { return x * 2; };
    print(double(21));      // Should print 42

    // Anonymous function with type deduction
    let add = (int x, float y) -> float { return x + y; };
    print(add(3, 0.14));    // Should print 3.14

    // Test nested function type inference
    let makeAdder = (int x) -> fn<int>(int) {
        return (int y) -> int {
            return x + y;    // Captures x from outer scope
        };
    };
    let add5 = makeAdder(5);
    print(add5(3));         // Should print 8
}

// Test class conversion methods
class Point {
    float x;
    float y;

    fn c!Point(str s) {
        // Format expected: "x,y"
        let parts = s.split(",");
        this.x = float(parts[0]);
        this.y = float(parts[1]);
    }

    fn toString() -> str {
        return "(" + str(this.x) + ", " + str(this.y) + ")";
    }
}

fn test_class_conversion() {
    let pointStr = "3.14,2.718";
    let point = c!Point(pointStr);
    print(point.toString());  // Should print "(3.14, 2.718)"
}

// Test nested type inference and scoping
fn test_nested_scopes() {
    let x = 42;  // int
    {
        let y = 3.14;  // float
        let sum = x + y;  // float (promotion)
        print(sum);  // Should print 45.14
        {
            let z = "nested";  // str
            print(z);
            let sum2 = x + y;  // Tests variable access from outer scopes
            print(sum2);
        }
    }
}

fn main() -> void {
    // Run all type system tests
    test_type_conversions();

    // Test function return types
    print(explicit_return_type(21));    // Should print 42
    print(implicit_return_type(21));    // Should print 42
    print(mixed_returns(1));            // Should print 1.0

    // Test anonymous functions and type inference
    test_anonymous_functions();

    // Test class type system
    test_class_conversion();

    // Test nested scopes and type inference
    test_nested_scopes();

    // Test const type inference
    const PI = 3.14159;
    const MAX_VALUE = 100;
    const GREETING = "Hello";
    print(PI);
    print(MAX_VALUE);
    print(GREETING);

    // Test generic function types
    fn apply(fn<int>(int) func, int value) -> int {
        return func(value);
    }
    let double = (int x) -> int { return x * 2; };
    print(apply(double, 21));  // Should print 42

    // Test nested function type inference
    let makeAdder = (int x) -> fn<int>(int) {
        return (int y) -> int {
            return x + y;    // Captures x from outer scope
        };
    };
    let add5 = makeAdder(5);
    print(add5(3));         // Should print 8

    return;
}
