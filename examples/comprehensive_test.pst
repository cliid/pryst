// Test all language features comprehensively

// 1. Module imports and usage
import pryst::web;
import pryst::utils;
import pryst::core::math;  // Test nested module import
import pryst::core::string as str_utils;  // Test module alias

// 2. Interface definitions
interface Printable {
    fn toString() -> str;
}

interface Comparable<T> {
    fn compareTo(T other) -> int;
}

interface Drawable {
    fn draw() -> void;
}

interface Resizable {
    fn resize(float factor) -> void;
}

interface Container<T> {
    fn add(T item) -> void;
    fn get(int index) -> T;
    fn size() -> int;
}

interface NumberOperations<T : Number> {  // Type bound constraint
    fn sum(T other) -> T;
    fn multiply(T other) -> T;
}

// 3. Generic class with interface implementation
class Box<T> : Printable {
    T value;

    fn init(T initialValue) -> void {
        this.value = initialValue;
    }

    fn getValue() -> T {
        return this.value;
    }

    override fn toString() -> str {
        return "Box(" + str(this.value) + ")";
    }
}

// Base class for numeric operations
class Number {
    virtual fn toInt() -> int { return 0; }
    virtual fn toFloat() -> float { return 0.0; }
}

class Integer : Number, Comparable<Integer>, NumberOperations<Integer> {
    int value;

    fn init(int v) -> void {
        this.value = v;
    }

    override fn toInt() -> int {
        return this.value;
    }

    override fn toFloat() -> float {
        return float(this.value);
    }

    override fn compareTo(Integer other) -> int {
        return this.value - other.value;
    }

    override fn sum(Integer other) -> Integer {
        return new Integer(this.value + other.value);
    }

    override fn multiply(Integer other) -> Integer {
        return new Integer(this.value * other.value);
    }
}

// 4. Function type declarations
fn<int> add(int x, int y) {
    return x + y;
}

fn<float> add(float x, float y) {
    return x + y;
}

// 5. Lambda functions with arrow syntax
let multiply = (int x, int y) -> int {
    return x * y;
};

// 6. Class definition and method calls
class UIElement {
    float x;
    float y;

    virtual fn move(float dx, float dy) -> void {
        this.x += dx;
        this.y += dy;
    }

    virtual fn getPosition() -> str {
        return "({this.x}, {this.y})";
    }
}

class Shape {
    str name;
    const float PI = 3.14159;

    fn init(str n) -> void {
        this.name = n;
    }

    virtual fn area() -> float {
        return 0.0;
    }

    const fn getName() -> str {
        return this.name;
    }
}

class Circle : Shape {
    float radius;

    fn init(str n, float r) -> void {
        super.init(n);
        this.radius = r;
    }

    override fn area() -> float {
        return PI * radius * radius;
    }
}

class Button : UIElement, Drawable, Resizable {
    str label;
    float width;
    float height;

    fn init(str text, float x, float y) -> void {
        this.label = text;
        this.x = x;
        this.y = y;
        this.width = 100.0;
        this.height = 30.0;
    }

    override fn draw() -> void {
        print("Drawing button '{this.label}' at {this.getPosition()}");
    }

    override fn resize(float factor) -> void {
        this.width *= factor;
        this.height *= factor;
    }
}

class Calculator {
    fn add(int x, int y) -> int {
        return x + y;
    }

    fn multiply(int x, int y) -> int {
        return x * y;
    }
}

// 7. Block-level scoping and using declarations
fn testScoping() -> void {
    // Test block scoping
    {
        using module web;
        print("Inside block: " + host());
    }

    // Outside block should use full qualification
    print("Outside block: " + web::host());
}

// 8. Const declarations
const PI = 3.14159;  // Type inference
const! MAX_VALUE = 100;  // Constexpr
const int MIN_VALUE = 0;  // Explicit typing

// 9. String interpolation
fn testInterpolation() -> void {
    let name = "Alice";
    let age = 30;
    print("Name: {name}, Age: {age}");
    print("Pi is {PI:.2f}");
}

// 10. Nested functions
fn outer() -> void {
    fn inner(int x) -> int {
        return x * 2;
    }
    print("Inner result: " + inner(5).toString());
}

// 11. Type casting tests
fn testTypeCasting() -> void {
    let intVal = 42;
    let floatVal = float(intVal);      // Function-style cast
    let strVal = str(floatVal);        // Convert to string
    let backToInt = int("123");        // String to int
    let boolVal = bool(1);             // Int to bool
    let explicitFloat = (float)intVal;  // C-style cast
}

// 12. Error handling tests
fn testErrorHandling() -> void {
    try {
        let result = int("not a number");
    } catch (ParseError e) {
        print("Caught parse error: " + e.message);
    }

    try {
        let arr = [1, 2, 3];
        let invalid = arr[5];
    } catch (IndexError e) {
        print("Caught index error: " + e.message);
    }
}

// 13. Generic function test
fn<T> swap<T>(T a, T b) -> void {
    let temp = a;
    a = b;
    b = temp;
}

// 14. Template constraints test
fn testTemplateConstraints() -> void {
    // Test Number operations
    let num1 = new Integer(5);
    let num2 = new Integer(3);
    let sum = num1.sum(num2);
    let product = num1.multiply(num2);
    print("Sum: " + sum.toInt().toString());
    print("Product: " + product.toInt().toString());

    // Test const correctness
    try {
        const num = new Integer(10);
        num.value = 20;  // Should throw error - modifying const object
    } catch (ConstError e) {
        print("Caught const error: " + e.message);
    }

    // Test type bound constraints
    try {
        class InvalidNumber : NumberOperations<str> {  // Should fail - str is not a Number
            // Implementation
        }
    } catch (TypeError e) {
        print("Caught type error: " + e.message);
    }
}

fn main() -> int {
    // Test class instantiation and method calls
    let calc = new Calculator();
    print("Calculator add: " + calc.add(5, 3).toString());
    print("Calculator multiply: " + calc.multiply(4, 2).toString());

    // Test inheritance and polymorphism
    let circle = new Circle("Circle1", 5.0);
    print("Shape name: " + circle.getName());
    print("Circle area: " + circle.area().toString());

    // Test generic class
    let intBox = new Box<int>(42);
    print(intBox.toString());
    let strBox = new Box<str>("Hello");
    print(strBox.toString());

    // Test multiple inheritance and interfaces
    let button = new Button("Click me", 100.0, 100.0);
    button.draw();
    button.move(10.0, 20.0);
    button.resize(1.5);
    button.draw();

    // Test lambda functions
    let result1 = multiply(6, 7);
    print("Lambda multiply: " + result1.toString());

    // Test block scoping
    testScoping();

    // Test string interpolation
    testInterpolation();

    // Test nested functions
    outer();

    // Test const values
    print("PI: " + PI.toString());
    print("MAX_VALUE: " + MAX_VALUE.toString());
    print("MIN_VALUE: " + MIN_VALUE.toString());

    // Test type casting
    testTypeCasting();

    // Test error handling
    testErrorHandling();

    // Test module usage with different syntaxes
    {
        using module pryst::web;
        host();  // Direct call
    }
    {
        using namespace pryst;
        web::host();  // Namespace qualified call
    }
    {
        using module pryst::core::math;
        sqrt(16.0);  // Direct call to nested module function
    }

    // Test error handling with type mismatches
    try {
        let invalidBox = new Box<int>("wrong type");
    } catch (TypeError e) {
        print("Caught type error: " + e.message);
    }

    // Test generic function
    let x = 5;
    let y = 10;
    swap<int>(x, y);
    print("After swap: x = " + x.toString() + ", y = " + y.toString());

    // Test template constraints
    print("\nTesting template constraints:");
    testTemplateConstraints();

    return 0;
}
