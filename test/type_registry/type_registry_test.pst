// Test basic type handling and LLVM 20.0.0 compatibility
fn testBasicTypes() -> void {
    // Test integer types
    let i8_val: i8 = 127;
    let i16_val: i16 = 32767;
    let i32_val: i32 = 2147483647;
    let i64_val: i64 = 9223372036854775807;

    // Test unsigned integer types
    let u8_val: u8 = 255;
    let u16_val: u16 = 65535;
    let u32_val: u32 = 4294967295;
    let u64_val: u64 = 18446744073709551615;

    // Test floating point types
    let f32_val: f32 = 3.14159;
    let f64_val: f64 = 2.718281828459045;

    // Test boolean type
    let bool_val: bool = true;

    // Test string type with opaque pointer handling
    let str_val: string = "Test string";
    print("String length: ${str_val.length()}");
}

// Test nullable types and runtime checks
fn testNullableTypes() -> void {
    // Test nullable primitive types
    let nullable_int: int? = null;
    let nullable_float: float? = 3.14;
    let nullable_bool: bool? = null;

    // Test nullable string
    let nullable_str: string? = "Can be null";
    nullable_str = null;

    // Test null checks
    try {
        print(nullable_int.toString());
    } catch (NullPointerException e) {
        print("Caught null pointer exception as expected");
    }

    // Test non-null assertion
    nullable_float = 42.0;
    let non_null = nullable_float!;
    print("Non-null value: ${non_null}");
}

// Test function types and type signatures
fn testFunctionTypes() -> void {
    // Define function type variables
    let binary_op: fn(int, int) -> int;
    let unary_op: fn(float) -> float;
    let void_func: fn() -> void;

    // Test function assignment
    binary_op = fn(int x, int y) -> int { return x + y; };
    unary_op = fn(float x) -> float { return x * x; };
    void_func = fn() -> void { print("void function"); };

    // Test function calls
    print("Binary op result: ${binary_op(5, 3)}");
    print("Unary op result: ${unary_op(2.5)}");
    void_func();
}

// Test type conversion and promotion
fn testTypeConversion() -> void {
    // Test numeric conversions
    let int_val: int = 42;
    let float_val: float = float(int_val);
    let str_val: string = string(int_val);

    // Test type promotion
    let promoted = int_val + 3.14;  // Should promote to float
    print("Promoted value: ${promoted}");

    // Test explicit conversions
    let explicit_int = int("42");
    let explicit_float = float("3.14");
    let explicit_bool = bool("true");

    // Test conversion errors
    try {
        let invalid = int("not a number");
    } catch (TypeConversionException e) {
        print("Caught conversion error: ${e.getMessage()}");
    }
}

// Test type metadata and reflection
fn testTypeMetadata() -> void {
    let val: any = 42;
    print("Type of val: ${typeof(val)}");
    print("Is number: ${is_number(val)}");
    print("Is nullable: ${is_nullable(val)}");
}

// Entry point
fn main() -> void {
    testBasicTypes();
    testNullableTypes();
    testFunctionTypes();
    testTypeConversion();
    testTypeMetadata();
}
