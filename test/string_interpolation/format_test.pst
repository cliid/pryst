// Test string formatting capabilities
fn testNumericFormatting() -> void {
    let integer = 42;
    let float = 3.14159;

    // Integer formatting
    print("Default: ${integer}");           // 42
    print("Padded: ${integer:5}");          // "   42"
    print("Zero-padded: ${integer:05}");    // "00042"
    print("Left-aligned: ${integer:<5}");   // "42   "
    print("Hex: ${integer:x}");             // "2a"
    print("HEX: ${integer:X}");             // "2A"
    print("Binary: ${integer:b}");          // "101010"
    print("Octal: ${integer:o}");           // "52"

    // Float formatting
    print("Default float: ${float}");           // 3.14159
    print("Fixed precision: ${float:.2}");      // 3.14
    print("Scientific: ${float:e}");            // 3.14159e+00
    print("Scientific caps: ${float:E}");       // 3.14159E+00
    print("Percentage: ${float:p}");            // 314.159%
    print("Width and precision: ${float:8.3}"); // "   3.142"
}

fn testStringFormatting() -> void {
    let text = "Hello";

    // String alignment and padding
    print("Right-aligned: ${text:>10}");    // "     Hello"
    print("Left-aligned: ${text:<10}");     // "Hello     "
    print("Centered: ${text:^10}");         // "  Hello   "
    print("Padded with *: ${text:*^10}");   // "**Hello***"

    // String truncation
    print("Truncated: ${text:.3}");         // "Hel"
}

fn testCustomFormatting() -> void {
    class Point {
        private float x;
        private float y;

        fn new(float x, float y) -> Point {
            this.x = x;
            this.y = y;
        }

        fn format(string spec) -> string {
            if spec == "p" {
                return string("(${this.x:.2}, ${this.y:.2})");
            } else if spec == "j" {
                return string("{\"x\": ${this.x}, \"y\": ${this.y}}");
            }
            return string("${this.x},${this.y}");
        }
    }

    let point = new Point(1.23456, 2.34567);
    print("Default: ${point}");         // "1.23456,2.34567"
    print("Pretty: ${point:p}");        // "(1.23, 2.35)"
    print("JSON: ${point:j}");          // {"x": 1.23456, "y": 2.34567}
}

fn testDateTimeFormatting() -> void {
    class DateTime {
        private int year;
        private int month;
        private int day;

        fn new(int y, int m, int d) -> DateTime {
            this.year = y;
            this.month = m;
            this.day = d;
        }

        fn format(string spec) -> string {
            if spec == "short" {
                return string("${this.month}/${this.day}/${this.year}");
            } else if spec == "long" {
                return string("${this.year}-${this.month:02}-${this.day:02}");
            }
            return string("${this.month}/${this.day}/${this.year}");
        }
    }

    let date = new DateTime(2024, 3, 15);
    print("Short format: ${date:short}");    // "3/15/2024"
    print("Long format: ${date:long}");      // "2024-03-15"
}

fn testErrorHandling() -> void {
    let number = 42;
    let text = "Hello";

    // Invalid format specifiers
    try {
        print("${number:invalid}");
    } catch (FormatException e) {
        print("Caught invalid number format: ${e.getMessage()}");
    }

    try {
        print("${text:999.999}");
    } catch (FormatException e) {
        print("Caught invalid string format: ${e.getMessage()}");
    }
}

fn testComplexFormatting() -> void {
    let items = ["apple", "banana", "orange"];
    let prices = [1.99, 0.99, 2.49];

    // Table formatting
    print("Item List:");
    print("-----------------");
    for (let i = 0; i < items.length(); i++) {
        print("${items[i]:<10} ${prices[i]:>6.2}");
    }

    // Complex nested formatting
    let total = prices.reduce((acc, price) => acc + price, 0.0);
    print("""
    Order Summary
    =============
    Items: ${items.length()}
    Total: ${total:>.2}
    Average: ${total / items.length():.3}
    """);
}

// Entry point
fn main() -> void {
    testNumericFormatting();
    testStringFormatting();
    testCustomFormatting();
    testDateTimeFormatting();
    testErrorHandling();
    testComplexFormatting();
}
