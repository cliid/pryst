// Test type conversion with reflection
class Base {
    value: int;

    fn getValue() -> int {
        return this.value;
    }
}

class Derived extends Base {
    extra: string;

    fn getExtra() -> string {
        return this.extra;
    }
}

fn testConversion(value: any, targetType: string) -> void {
    print("Converting " + getType(value) + " to " + targetType);
    try {
        let converted = convert(value, targetType);
        print("Conversion successful: " + str(isInstance(converted, targetType)));

        // Additional verification for numeric conversions
        if (targetType == "int" || targetType == "float") {
            print("Converted value: " + str(converted));
        }
    } catch (e) {
        print("Conversion failed: " + str(e));
    }
}

fn main() -> void {
    // Test numeric conversions
    let num = 42;
    testConversion(num, "float");    // Should succeed
    testConversion(num, "string");   // Should succeed

    let pi = 3.14159;
    testConversion(pi, "int");       // Should truncate
    testConversion(pi, "string");    // Should succeed

    // Test class conversions
    let derived = new Derived();
    derived.value = 100;
    derived.extra = "test";

    testConversion(derived, "Base");     // Should succeed
    testConversion(derived, "Object");   // Should succeed if Object is base class

    let base = new Base();
    base.value = 200;
    testConversion(base, "Derived");     // Should fail (upcast not allowed)

    // Test string conversions
    let text = "123";
    testConversion(text, "int");         // Should succeed
    testConversion(text, "float");       // Should succeed

    let invalid = "not a number";
    testConversion(invalid, "int");      // Should fail with error
    testConversion(invalid, "float");    // Should fail with error

    // Test boolean conversions
    let flag = true;
    testConversion(flag, "string");      // Should convert to "true"
    testConversion(flag, "int");         // Should convert to 1
}
