#pragma once

#include <llvm/IR/Type.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <memory>
#include <string>
#include <map>
#include <vector>
#include "utils/debug.hpp"

namespace pryst {

class LLVMTypeRegistry {
public:
    LLVMTypeRegistry(llvm::LLVMContext& context) : context(context) {
        initializeBasicTypes();
    }

    // Basic type getters
    llvm::Type* getVoidType() { return llvm::Type::getVoidTy(context); }
    llvm::Type* getIntType() { return llvm::Type::getInt32Ty(context); }
    llvm::Type* getFloatType() { return llvm::Type::getDoubleTy(context); }
    llvm::Type* getBoolType() { return llvm::Type::getInt1Ty(context); }
    llvm::Type* getInt8Type() { return llvm::Type::getInt8Ty(context); }
    llvm::Type* getInt64Type() { return llvm::Type::getInt64Ty(context); }

    // String type (opaque pointer to i8)
    llvm::Type* getStrType() {
        return getPointerType();  // Using opaque pointers for LLVM 20.0.0
    }

    // Pointer type handling for LLVM 20.0.0 opaque pointers
    llvm::Type* getPointerType() {
        return llvm::PointerType::get(context, 0);
    }

    // Function type creation with proper pointer handling
    llvm::FunctionType* getFunctionType(llvm::Type* returnType,
                                     const std::vector<llvm::Type*>& paramTypes,
                                     bool isVarArg = false) {
        // Handle void return type
        if (!returnType) {
            returnType = getVoidType();
        }
        return llvm::FunctionType::get(returnType, paramTypes, isVarArg);
    }

    // Create function type from string representation
    llvm::FunctionType* createFunctionType(const std::string& returnTypeName,
                                        const std::vector<std::string>& paramTypeNames,
                                        bool isVarArg = false) {
        llvm::Type* returnType = getTypeFromName(returnTypeName);
        std::vector<llvm::Type*> paramTypes;
        for (const auto& paramName : paramTypeNames) {
            paramTypes.push_back(getTypeFromName(paramName));
        }
        return getFunctionType(returnType, paramTypes, isVarArg);
    }

    // Array type creation
    llvm::ArrayType* getArrayType(llvm::Type* elementType, uint64_t size) {
        return llvm::ArrayType::get(elementType, size);
    }

    // Struct type creation with proper name handling
    llvm::StructType* getStructType(const std::vector<llvm::Type*>& elements,
                                  const std::string& name = "",
                                  bool isPacked = false) {
        if (name.empty()) {
            return llvm::StructType::get(context, elements, isPacked);
        }

        // Check for existing type first
        auto* existingType = llvm::StructType::getTypeByName(context, name);
        if (existingType) {
            return existingType;
        }

        // Create new named struct type
        auto* structType = llvm::StructType::create(context, name);
        structType->setBody(elements, isPacked);
        return structType;
    }

    // Type registration and lookup
    void registerType(const std::string& name, llvm::Type* type) {
        PRYST_DEBUG("Registering type: " + name);
        typeMap[name] = type;
    }

    llvm::Type* lookupType(const std::string& name) {
        auto it = typeMap.find(name);
        if (it != typeMap.end()) {
            return it->second;
        }
        PRYST_DEBUG("Type not found: " + name);
        return nullptr;
    }

    // Get type from name with proper error handling
    llvm::Type* getTypeFromName(const std::string& name) {
        if (name == "void") return getVoidType();
        if (name == "int") return getIntType();
        if (name == "float") return getFloatType();
        if (name == "bool") return getBoolType();
        if (name == "str") return getStrType();

        // Check registered types
        auto* type = lookupType(name);
        if (type) return type;

        // Handle pointer types (ending with *)
        if (name.length() > 1 && name.back() == '*') {
            return getPointerType();  // Using opaque pointers for LLVM 20.0.0
        }

        PRYST_DEBUG("Unknown type: " + name);
        return nullptr;
    }

    // Helper method to check if a type is a pointer type
    bool isPointerType(llvm::Type* type) {
        return type && type->isPointerTy();
    }

    // Helper method to get function type components
    std::pair<llvm::Type*, std::vector<llvm::Type*>> getFunctionTypeComponents(llvm::FunctionType* fnType) {
        std::vector<llvm::Type*> paramTypes(fnType->param_begin(), fnType->param_end());
        return {fnType->getReturnType(), paramTypes};
    }

private:
    void initializeBasicTypes() {
        registerType("void", getVoidType());
        registerType("int", getIntType());
        registerType("float", getFloatType());
        registerType("bool", getBoolType());
        registerType("str", getStrType());
        registerType("i8", getInt8Type());
        registerType("i64", getInt64Type());
    }

    llvm::LLVMContext& context;
    std::map<std::string, llvm::Type*> typeMap;
};

} // namespace pryst
