// Include LLVM headers first
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Constants.h>
#include <llvm/Support/Error.h>
#include <llvm/ExecutionEngine/Orc/ThreadSafeModule.h>

// Then include project headers
#include "llvm_codegen.hpp"
#include "utils/logger.hpp"
#include <memory>
#include <stdexcept>

namespace pryst {

LLVMCodegen::LLVMCodegen()
    : context(std::make_unique<llvm::LLVMContext>()),
      typeRegistry(*context) {
    PRYST_DEBUG("Initializing LLVMCodegen");
}

std::unique_ptr<llvm::Module> LLVMCodegen::generateModule(PrystParser::ProgramContext* ctx) {
    if (!ctx) {
        PRYST_ERROR("Null program context provided to generateModule");
        return nullptr;
    }

    PRYST_DEBUG("Generating LLVM IR module");
    module = std::make_unique<llvm::Module>("pryst_module", *context);
    builder = std::make_unique<llvm::IRBuilder<>>(*context);

    // Initialize built-in types
    typeRegistry.initialize();

    // Declare external functions (print, etc.)
    declarePrintFunctions();

    // Visit all top-level declarations
    try {
        visitProgram(ctx);
    } catch (const std::exception& e) {
        PRYST_ERROR("Error during code generation: " + std::string(e.what()));
        return nullptr;
    }

    // Verify the module
    std::string errorInfo;
    llvm::raw_string_ostream errorStream(errorInfo);
    if (llvm::verifyModule(*module, &errorStream)) {
        PRYST_ERROR("Module verification failed: " + errorInfo);
        return nullptr;
    }

    PRYST_DEBUG("Module generation completed successfully");
    return std::move(module);
}

std::any LLVMCodegen::visitProgram(PrystParser::ProgramContext* ctx) {
    PRYST_DEBUG("Visiting program");

    // Visit all declarations in the program
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }

    return nullptr;
}

void LLVMCodegen::declarePrintFunctions() {
    PRYST_DEBUG("Declaring print functions");

    // Get necessary types
    auto voidType = typeRegistry.getVoidType();
    auto int32Type = typeRegistry.getIntType(32);
    auto floatType = typeRegistry.getFloatType();
    auto boolType = typeRegistry.getBoolType();
    auto strType = typeRegistry.getStringType();

    // Declare print functions for different types
    std::vector<llvm::Type*> printIntArgs = {int32Type};
    auto printIntType = llvm::FunctionType::get(voidType, printIntArgs, false);
    printFunctions["int"] = module->getOrInsertFunction("pryst_print_int", printIntType).getCallee();

    std::vector<llvm::Type*> printFloatArgs = {floatType};
    auto printFloatType = llvm::FunctionType::get(voidType, printFloatArgs, false);
    printFunctions["float"] = module->getOrInsertFunction("pryst_print_float", printFloatType).getCallee();

    std::vector<llvm::Type*> printBoolArgs = {boolType};
    auto printBoolType = llvm::FunctionType::get(voidType, printBoolArgs, false);
    printFunctions["bool"] = module->getOrInsertFunction("pryst_print_bool", printBoolType).getCallee();

    std::vector<llvm::Type*> printStrArgs = {strType};
    auto printStrType = llvm::FunctionType::get(voidType, printStrArgs, false);
    printFunctions["str"] = module->getOrInsertFunction("pryst_print_str", printStrType).getCallee();
}

std::any LLVMCodegen::visitFunctionDecl(PrystParser::FunctionDeclContext* ctx) {
    PRYST_DEBUG("Visiting function declaration");

    std::string name = ctx->IDENTIFIER()->getText();
    auto returnType = typeRegistry.getLLVMType(ctx->type()->getText());

    // Get parameter types
    std::vector<llvm::Type*> paramTypes;
    if (ctx->parameters()) {
        for (auto param : ctx->parameters()->parameter()) {
            paramTypes.push_back(typeRegistry.getLLVMType(param->type()->getText()));
        }
    }

    // Create function type
    auto functionType = llvm::FunctionType::get(returnType, paramTypes, false);

    // Create function
    auto function = llvm::Function::Create(
        functionType,
        llvm::Function::ExternalLinkage,
        name,
        module.get()
    );

    // Create entry block
    auto entryBlock = llvm::BasicBlock::Create(*context, "entry", function);
    builder->SetInsertPoint(entryBlock);

    // Store current function
    auto prevFunction = currentFunction;
    currentFunction = function;

    // Create allocas for parameters
    if (ctx->parameters()) {
        auto paramIt = function->arg_begin();
        for (auto param : ctx->parameters()->parameter()) {
            std::string paramName = param->IDENTIFIER()->getText();
            auto alloca = createEntryBlockAlloca(function, paramName, paramIt->getType());
            builder->CreateStore(&*paramIt, alloca);
            namedValues[paramName] = alloca;
            ++paramIt;
        }
    }

    // Visit function body
    if (ctx->block()) {
        visit(ctx->block());
    }

    // Add return instruction if needed
    if (!builder->GetInsertBlock()->getTerminator()) {
        if (returnType->isVoidTy()) {
            builder->CreateRetVoid();
        } else {
            // Create a default return value based on type
            llvm::Value* defaultValue = nullptr;
            if (returnType->isIntegerTy()) {
                defaultValue = llvm::ConstantInt::get(returnType, 0);
            } else if (returnType->isFloatingPointTy()) {
                defaultValue = llvm::ConstantFP::get(returnType, 0.0);
            } else {
                defaultValue = llvm::Constant::getNullValue(returnType);
            }
            builder->CreateRet(defaultValue);
        }
    }

    // Restore previous function
    currentFunction = prevFunction;

    return nullptr;
}

std::any LLVMCodegen::visitClassDecl(PrystParser::ClassDeclContext* ctx) {
    PRYST_DEBUG("Visiting class declaration");

    std::string className = ctx->IDENTIFIER()->getText();

    // Create struct type for class
    std::vector<llvm::Type*> memberTypes;
    std::vector<std::string> memberNames;

    // Add member variables
    for (auto member : ctx->classBody()->memberDecl()) {
        if (member->variableDecl()) {
            auto varDecl = member->variableDecl();
            memberTypes.push_back(typeRegistry.getLLVMType(varDecl->type()->getText()));
            memberNames.push_back(varDecl->IDENTIFIER()->getText());
        }
    }

    // Register class type
    auto classType = llvm::StructType::create(*context, memberTypes, className);
    typeRegistry.registerClassType(className, classType, memberNames);

    // Generate methods
    for (auto member : ctx->classBody()->memberDecl()) {
        if (member->methodDecl()) {
            visit(member->methodDecl());
        }
    }

    return nullptr;
}

std::any LLVMCodegen::visitMethodDecl(PrystParser::MethodDeclContext* ctx) {
    PRYST_DEBUG("Visiting method declaration");

    std::string methodName = ctx->IDENTIFIER()->getText();
    auto returnType = typeRegistry.getLLVMType(ctx->type()->getText());

    // Get parameter types including 'this' pointer
    std::vector<llvm::Type*> paramTypes;
    std::string className = currentClass;
    auto classType = typeRegistry.getClassType(className);
    paramTypes.push_back(classType->getPointerTo()); // 'this' pointer

    if (ctx->parameters()) {
        for (auto param : ctx->parameters()->parameter()) {
            paramTypes.push_back(typeRegistry.getLLVMType(param->type()->getText()));
        }
    }

    // Create function type
    auto functionType = llvm::FunctionType::get(returnType, paramTypes, false);

    // Create function with mangled name
    std::string mangledName = className + "_" + methodName;
    auto function = llvm::Function::Create(
        functionType,
        llvm::Function::ExternalLinkage,
        mangledName,
        module.get()
    );

    // Create entry block
    auto entryBlock = llvm::BasicBlock::Create(*context, "entry", function);
    builder->SetInsertPoint(entryBlock);

    // Store current function
    auto prevFunction = currentFunction;
    currentFunction = function;

    // Create allocas for parameters including 'this'
    auto paramIt = function->arg_begin();
    auto thisValue = &*paramIt++;
    auto thisAlloca = createEntryBlockAlloca(function, "this", thisValue->getType());
    builder->CreateStore(thisValue, thisAlloca);
    namedValues["this"] = thisAlloca;

    if (ctx->parameters()) {
        for (auto param : ctx->parameters()->parameter()) {
            std::string paramName = param->IDENTIFIER()->getText();
            auto alloca = createEntryBlockAlloca(function, paramName, paramIt->getType());
            builder->CreateStore(&*paramIt, alloca);
            namedValues[paramName] = alloca;
            ++paramIt;
        }
    }

    // Visit method body
    if (ctx->block()) {
        visit(ctx->block());
    }

    // Add return instruction if needed
    if (!builder->GetInsertBlock()->getTerminator()) {
        if (returnType->isVoidTy()) {
            builder->CreateRetVoid();
        } else {
            // Create a default return value based on type
            llvm::Value* defaultValue = nullptr;
            if (returnType->isIntegerTy()) {
                defaultValue = llvm::ConstantInt::get(returnType, 0);
            } else if (returnType->isFloatingPointTy()) {
                defaultValue = llvm::ConstantFP::get(returnType, 0.0);
            } else {
                defaultValue = llvm::Constant::getNullValue(returnType);
            }
            builder->CreateRet(defaultValue);
        }
    }

    // Restore previous function
    currentFunction = prevFunction;

    return nullptr;
}

std::any LLVMCodegen::visitVariableDecl(PrystParser::VariableDeclContext* ctx) {
    PRYST_DEBUG("Visiting variable declaration");

    std::string name = ctx->IDENTIFIER()->getText();
    auto type = typeRegistry.getLLVMType(ctx->type()->getText());

    // Create alloca for variable
    auto alloca = createEntryBlockAlloca(currentFunction, name, type);
    namedValues[name] = alloca;

    // Initialize variable if there's an initializer
    if (ctx->expression()) {
        auto initValue = std::any_cast<llvm::Value*>(visit(ctx->expression()));
        builder->CreateStore(initValue, alloca);
    } else {
        // Initialize with default value
        llvm::Value* defaultValue = nullptr;
        if (type->isIntegerTy()) {
            defaultValue = llvm::ConstantInt::get(type, 0);
        } else if (type->isFloatingPointTy()) {
            defaultValue = llvm::ConstantFP::get(type, 0.0);
        } else {
            defaultValue = llvm::Constant::getNullValue(type);
        }
        builder->CreateStore(defaultValue, alloca);
    }

    return nullptr;
}

std::any LLVMCodegen::visitBlock(PrystParser::BlockContext* ctx) {
    PRYST_DEBUG("Visiting block");

    // Visit all statements in the block
    for (auto stmt : ctx->statement()) {
        visit(stmt);

        // Check if the last statement was a terminator
        if (builder->GetInsertBlock()->getTerminator()) {
            break;
        }
    }

    return nullptr;
}

std::any LLVMCodegen::visitExpressionStmt(PrystParser::ExpressionStmtContext* ctx) {
    PRYST_DEBUG("Visiting expression statement");
    return visit(ctx->expression());
}

std::any LLVMCodegen::visitIfStmt(PrystParser::IfStmtContext* ctx) {
    PRYST_DEBUG("Visiting if statement");

    // Generate condition
    auto condValue = std::any_cast<llvm::Value*>(visit(ctx->expression()));

    // Create basic blocks
    auto thenBB = llvm::BasicBlock::Create(*context, "then", currentFunction);
    auto elseBB = ctx->elseBlock ? llvm::BasicBlock::Create(*context, "else", currentFunction) : nullptr;
    auto mergeBB = llvm::BasicBlock::Create(*context, "ifcont", currentFunction);

    // Create conditional branch
    builder->CreateCondBr(condValue, thenBB, elseBB ? elseBB : mergeBB);

    // Generate 'then' block
    builder->SetInsertPoint(thenBB);
    visit(ctx->block());
    if (!builder->GetInsertBlock()->getTerminator()) {
        builder->CreateBr(mergeBB);
    }

    // Generate 'else' block if it exists
    if (elseBB) {
        builder->SetInsertPoint(elseBB);
        visit(ctx->elseBlock);
        if (!builder->GetInsertBlock()->getTerminator()) {
            builder->CreateBr(mergeBB);
        }
    }

    // Continue in merge block
    builder->SetInsertPoint(mergeBB);

    return nullptr;
}

std::any LLVMCodegen::visitWhileStmt(PrystParser::WhileStmtContext* ctx) {
    PRYST_DEBUG("Visiting while statement");

    // Create basic blocks
    auto condBB = llvm::BasicBlock::Create(*context, "cond", currentFunction);
    auto loopBB = llvm::BasicBlock::Create(*context, "loop", currentFunction);
    auto afterBB = llvm::BasicBlock::Create(*context, "afterloop", currentFunction);

    // Branch to condition block
    builder->CreateBr(condBB);

    // Generate condition block
    builder->SetInsertPoint(condBB);
    auto condValue = std::any_cast<llvm::Value*>(visit(ctx->expression()));
    builder->CreateCondBr(condValue, loopBB, afterBB);

    // Generate loop block
    builder->SetInsertPoint(loopBB);
    visit(ctx->block());
    if (!builder->GetInsertBlock()->getTerminator()) {
        builder->CreateBr(condBB);
    }

    // Continue in after block
    builder->SetInsertPoint(afterBB);

    return nullptr;
}

std::any LLVMCodegen::visitReturnStmt(PrystParser::ReturnStmtContext* ctx) {
    PRYST_DEBUG("Visiting return statement");

    if (!ctx->expression()) {
        return builder->CreateRetVoid();
    }

    auto retValue = std::any_cast<llvm::Value*>(visit(ctx->expression()));
    return builder->CreateRet(retValue);
}

std::any LLVMCodegen::visitCall(PrystParser::CallContext* ctx) {
    PRYST_DEBUG("Visiting function call");

    std::string callee = ctx->IDENTIFIER()->getText();

    // Get function from module
    llvm::Function* function = module->getFunction(callee);
    if (!function) {
        PRYST_ERROR("Unknown function: " + callee);
        return nullptr;
    }

    // Check argument count
    std::vector<llvm::Value*> args;
    if (ctx->arguments()) {
        for (auto arg : ctx->arguments()->expression()) {
            args.push_back(std::any_cast<llvm::Value*>(visit(arg)));
        }
    }


    if (args.size() != function->arg_size()) {
        PRYST_ERROR("Incorrect number of arguments for function: " + callee);
        return nullptr;
    }

    return builder->CreateCall(function, args);
}

std::any LLVMCodegen::visitBinary(PrystParser::BinaryContext* ctx) {
    PRYST_DEBUG("Visiting binary expression");

    auto left = std::any_cast<llvm::Value*>(visit(ctx->expression(0)));
    auto right = std::any_cast<llvm::Value*>(visit(ctx->expression(1)));
    std::string op = ctx->op->getText();

    if (left->getType()->isIntegerTy()) {
        if (op == "+") return builder->CreateAdd(left, right);
        if (op == "-") return builder->CreateSub(left, right);
        if (op == "*") return builder->CreateMul(left, right);
        if (op == "/") return builder->CreateSDiv(left, right);
        if (op == "%") return builder->CreateSRem(left, right);
        if (op == "<") return builder->CreateICmpSLT(left, right);
        if (op == "<=") return builder->CreateICmpSLE(left, right);
        if (op == ">") return builder->CreateICmpSGT(left, right);
        if (op == ">=") return builder->CreateICmpSGE(left, right);
        if (op == "==") return builder->CreateICmpEQ(left, right);
        if (op == "!=") return builder->CreateICmpNE(left, right);
    } else if (left->getType()->isFloatingPointTy()) {
        if (op == "+") return builder->CreateFAdd(left, right);
        if (op == "-") return builder->CreateFSub(left, right);
        if (op == "*") return builder->CreateFMul(left, right);
        if (op == "/") return builder->CreateFDiv(left, right);
        if (op == "<") return builder->CreateFCmpOLT(left, right);
        if (op == "<=") return builder->CreateFCmpOLE(left, right);
        if (op == ">") return builder->CreateFCmpOGT(left, right);
        if (op == ">=") return builder->CreateFCmpOGE(left, right);
        if (op == "==") return builder->CreateFCmpOEQ(left, right);
        if (op == "!=") return builder->CreateFCmpONE(left, right);
    }

    if (op == "&&") {
        auto andBB = llvm::BasicBlock::Create(*context, "and", currentFunction);
        auto mergeBB = llvm::BasicBlock::Create(*context, "merge", currentFunction);

        builder->CreateCondBr(left, andBB, mergeBB);

        builder->SetInsertPoint(andBB);
        builder->CreateBr(mergeBB);

        builder->SetInsertPoint(mergeBB);
        auto phi = builder->CreatePHI(llvm::Type::getInt1Ty(*context), 2);
        phi->addIncoming(llvm::ConstantInt::getFalse(*context), builder->GetInsertBlock());
        phi->addIncoming(right, andBB);

        return phi;
    }

    if (op == "||") {
        auto orBB = llvm::BasicBlock::Create(*context, "or", currentFunction);
        auto mergeBB = llvm::BasicBlock::Create(*context, "merge", currentFunction);

        builder->CreateCondBr(left, mergeBB, orBB);

        builder->SetInsertPoint(orBB);
        builder->CreateBr(mergeBB);

        builder->SetInsertPoint(mergeBB);
        auto phi = builder->CreatePHI(llvm::Type::getInt1Ty(*context), 2);
        phi->addIncoming(llvm::ConstantInt::getTrue(*context), builder->GetInsertBlock());
        phi->addIncoming(right, orBB);

        return phi;
    }

    PRYST_ERROR("Unknown binary operator: " + op);
    return nullptr;
}

std::any LLVMCodegen::visitUnary(PrystParser::UnaryContext* ctx) {
    PRYST_DEBUG("Visiting unary expression");

    auto operand = std::any_cast<llvm::Value*>(visit(ctx->expression()));
    std::string op = ctx->op->getText();

    if (op == "-") {
        if (operand->getType()->isIntegerTy()) {
            return builder->CreateNeg(operand);
        } else if (operand->getType()->isFloatingPointTy()) {
            return builder->CreateFNeg(operand);
        }
    } else if (op == "!") {
        return builder->CreateNot(operand);
    }

    PRYST_ERROR("Unknown unary operator: " + op);
    return nullptr;
}

std::any LLVMCodegen::visitLiteral(PrystParser::LiteralContext* ctx) {
    PRYST_DEBUG("Visiting literal");

    if (ctx->INTEGER()) {
        int value = std::stoi(ctx->INTEGER()->getText());
        return builder->CreateIntCast(
            llvm::ConstantInt::get(llvm::Type::getInt64Ty(*context), value),
            llvm::Type::getInt32Ty(*context),
            true
        );
    }

    if (ctx->FLOAT()) {
        float value = std::stof(ctx->FLOAT()->getText());
        return llvm::ConstantFP::get(llvm::Type::getFloatTy(*context), value);
    }

    if (ctx->BOOLEAN()) {
        bool value = ctx->BOOLEAN()->getText() == "true";
        return llvm::ConstantInt::get(llvm::Type::getInt1Ty(*context), value);
    }

    if (ctx->STRING()) {
        std::string str = ctx->STRING()->getText();
        str = str.substr(1, str.length() - 2); // Remove quotes
        return builder->CreateGlobalStringPtr(str);
    }

    PRYST_ERROR("Unknown literal type");
    return nullptr;
}

std::any LLVMCodegen::visitVariable(PrystParser::VariableContext* ctx) {
    PRYST_DEBUG("Visiting variable");

    std::string name = ctx->IDENTIFIER()->getText();
    auto value = namedValues[name];
    if (!value) {
        PRYST_ERROR("Unknown variable name: " + name);
        return nullptr;
    }

    return builder->CreateLoad(value->getType()->getPointerElementType(), value);
}

std::any LLVMCodegen::visitAssignment(PrystParser::AssignmentContext* ctx) {
    PRYST_DEBUG("Visiting assignment");

    std::string name = ctx->IDENTIFIER()->getText();
    auto value = std::any_cast<llvm::Value*>(visit(ctx->expression()));
    auto variable = namedValues[name];

    if (!variable) {
        PRYST_ERROR("Unknown variable name: " + name);
        return nullptr;
    }

    return builder->CreateStore(value, variable);
}

std::any LLVMCodegen::visitLambda(PrystParser::LambdaContext* ctx) {
    PRYST_DEBUG("Visiting lambda expression");

    // Create a unique name for the lambda
    static int lambdaCount = 0;
    std::string name = "lambda_" + std::to_string(lambdaCount++);

    // Get return type
    auto returnType = typeRegistry.getLLVMType(ctx->type()->getText());

    // Get parameter types
    std::vector<llvm::Type*> paramTypes;
    if (ctx->parameters()) {
        for (auto param : ctx->parameters()->parameter()) {
            paramTypes.push_back(typeRegistry.getLLVMType(param->type()->getText()));
        }
    }

    // Create function type
    auto functionType = llvm::FunctionType::get(returnType, paramTypes, false);

    // Create function
    auto function = llvm::Function::Create(
        functionType,
        llvm::Function::ExternalLinkage,
        name,
        module.get()
    );

    // Create entry block
    auto entryBlock = llvm::BasicBlock::Create(*context, "entry", function);
    builder->SetInsertPoint(entryBlock);

    // Store current function
    auto prevFunction = currentFunction;
    currentFunction = function;

    // Create allocas for parameters
    if (ctx->parameters()) {
        auto paramIt = function->arg_begin();
        for (auto param : ctx->parameters()->parameter()) {
            std::string paramName = param->IDENTIFIER()->getText();
            auto alloca = createEntryBlockAlloca(function, paramName, paramIt->getType());
            builder->CreateStore(&*paramIt, alloca);
            namedValues[paramName] = alloca;
            ++paramIt;
        }
    }

    // Visit lambda body
    if (ctx->block()) {
        visit(ctx->block());
    }

    // Add return instruction if needed
    if (!builder->GetInsertBlock()->getTerminator()) {
        if (returnType->isVoidTy()) {
            builder->CreateRetVoid();
        } else {
            // Create a default return value based on type
            llvm::Value* defaultValue = nullptr;
            if (returnType->isIntegerTy()) {
                defaultValue = llvm::ConstantInt::get(returnType, 0);
            } else if (returnType->isFloatingPointTy()) {
                defaultValue = llvm::ConstantFP::get(returnType, 0.0);
            } else {
                defaultValue = llvm::Constant::getNullValue(returnType);
            }
            builder->CreateRet(defaultValue);
        }
    }

    // Restore previous function
    currentFunction = prevFunction;

    return function;
}

std::any LLVMCodegen::visitNamespace(PrystParser::NamespaceContext* ctx) {
    PRYST_DEBUG("Visiting namespace");

    // Push namespace onto stack
    currentNamespace.push_back(ctx->IDENTIFIER()->getText());

    // Visit all declarations in namespace
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }

    // Pop namespace from stack
    currentNamespace.pop_back();

    return nullptr;
}

std::any LLVMCodegen::visitModule(PrystParser::ModuleContext* ctx) {
    PRYST_DEBUG("Visiting module");

    // Set current module
    currentModule = ctx->IDENTIFIER()->getText();

    // Visit all declarations in module
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }

    // Clear current module
    currentModule.clear();

    return nullptr;
}

std::any LLVMCodegen::visitImport(PrystParser::ImportContext* ctx) {
    PRYST_DEBUG("Visiting import");
    // Import handling is done in semantic analysis phase
    return nullptr;
}

std::any LLVMCodegen::visitUsingDecl(PrystParser::UsingDeclContext* ctx) {
    PRYST_DEBUG("Visiting using declaration");
    // Using declaration handling is done in semantic analysis phase
    return nullptr;
}

llvm::Function* LLVMCodegen::getFunctionProto(const std::string& name, llvm::FunctionType* type) {
    // Check if function already exists in module
    auto function = module->getFunction(name);
    if (!function) {
        function = llvm::Function::Create(type, llvm::Function::ExternalLinkage, name, module.get());
    }
    return function;
}

llvm::Value* LLVMCodegen::getVariableValue(const std::string& name) {
    auto it = namedValues.find(name);
    if (it != namedValues.end()) {
        return builder->CreateLoad(it->second->getType()->getPointerElementType(), it->second);
    }
    return nullptr;
}

llvm::AllocaInst* LLVMCodegen::createEntryBlockAlloca(llvm::Function* function, const std::string& varName, llvm::Type* type) {
    llvm::IRBuilder<> tmpBuilder(&function->getEntryBlock(), function->getEntryBlock().begin());
    return tmpBuilder.CreateAlloca(type, nullptr, varName);
}

void LLVMCodegen::createBasicBlock(const std::string& name) {
    llvm::BasicBlock::Create(*context, name, currentFunction);
}

llvm::Value* LLVMCodegen::createCastInstruction(llvm::Value* value, llvm::Type* destType, bool isSigned) {
    if (value->getType() == destType) {
        return value;
    }

    if (value->getType()->isIntegerTy() && destType->isIntegerTy()) {
        return builder->CreateIntCast(value, destType, isSigned);
    }

    if (value->getType()->isIntegerTy() && destType->isFloatingPointTy()) {
        return builder->CreateSIToFP(value, destType);
    }

    if (value->getType()->isFloatingPointTy() && destType->isIntegerTy()) {
        return builder->CreateFPToSI(value, destType);
    }

    if (value->getType()->isFloatingPointTy() && destType->isFloatingPointTy()) {
        return builder->CreateFPCast(value, destType);
    }

    PRYST_ERROR("Unsupported type cast");
    return nullptr;
}

} // namespace pryst
