#include "llvm_codegen.hpp"
#include "utils/logger.hpp"
#include <llvm/IR/Verifier.h>
#include <llvm/Support/raw_ostream.h>
#include <sstream>
#include <any>

namespace pryst {

std::any LLVMCodegen::visitNamespace(PrystParser::NamespaceContext* ctx) {
    PRYST_DEBUG("Visiting namespace: " + ctx->name->getText());
    currentNamespace.push_back(ctx->name->getText());
    visit(ctx->body);
    currentNamespace.pop_back();
    return std::any();
}

std::any LLVMCodegen::visitModule(PrystParser::ModuleContext* ctx) {
    PRYST_DEBUG("Visiting module: " + ctx->name->getText());
    auto prevModule = currentModule;
    currentModule = ctx->name->getText();
    visit(ctx->body);
    currentModule = prevModule;
    return std::any();
}

std::any LLVMCodegen::visitImport(PrystParser::ImportContext* ctx) {
    PRYST_DEBUG("Visiting import: " + ctx->path->getText());
    return std::any();
}

std::any LLVMCodegen::visitUsingDecl(PrystParser::UsingDeclContext* ctx) {
    PRYST_DEBUG("Visiting using declaration: " + ctx->path->getText());
    return std::any();
}

std::any LLVMCodegen::visitBlock(PrystParser::BlockContext* ctx) {
    PRYST_DEBUG("Visiting block");
    for (auto stmt : ctx->statement()) {
        visit(stmt);
    }
    return std::any();
}

std::any LLVMCodegen::visitExpressionStmt(PrystParser::ExpressionStmtContext* ctx) {
    PRYST_DEBUG("Visiting expression statement");
    return visit(ctx->expression());
}

std::any LLVMCodegen::visitIfStmt(PrystParser::IfStmtContext* ctx) {
    PRYST_DEBUG("Visiting if statement");

    auto conditionAny = visit(ctx->condition);
    if (!conditionAny.has_value()) {
        return std::any();
    }

    llvm::Value* condition = std::any_cast<llvm::Value*>(conditionAny);
    if (!condition->getType()->isIntegerTy(1)) {
        condition = builder->CreateICmpNE(condition,
            llvm::ConstantInt::get(typeRegistry.getIntType(32), 0));
    }

    llvm::Function* function = builder->GetInsertBlock()->getParent();
    auto thenBlock = llvm::BasicBlock::Create(*context, "then", function);
    auto elseBlock = llvm::BasicBlock::Create(*context, "else");
    auto mergeBlock = llvm::BasicBlock::Create(*context, "ifcont");

    builder->CreateCondBr(condition, thenBlock, elseBlock);

    // Then block
    builder->SetInsertPoint(thenBlock);
    visit(ctx->thenBranch);
    if (!thenBlock->getTerminator()) {
        builder->CreateBr(mergeBlock);
    }

    // Else block
    function->getBasicBlockList().push_back(elseBlock);
    builder->SetInsertPoint(elseBlock);
    if (ctx->elseBranch) {
        visit(ctx->elseBranch);
    }
    if (!elseBlock->getTerminator()) {
        builder->CreateBr(mergeBlock);
    }

    // Merge block
    function->getBasicBlockList().push_back(mergeBlock);
    builder->SetInsertPoint(mergeBlock);

    return std::any();
}

std::any LLVMCodegen::visitWhileStmt(PrystParser::WhileStmtContext* ctx) {
    PRYST_DEBUG("Visiting while statement");

    llvm::Function* function = builder->GetInsertBlock()->getParent();
    auto condBlock = llvm::BasicBlock::Create(*context, "loopcond", function);
    auto loopBlock = llvm::BasicBlock::Create(*context, "loop");
    auto afterBlock = llvm::BasicBlock::Create(*context, "afterloop");

    builder->CreateBr(condBlock);
    builder->SetInsertPoint(condBlock);

    auto conditionAny = visit(ctx->condition);
    if (!conditionAny.has_value()) {
        return std::any();
    }

    llvm::Value* condition = std::any_cast<llvm::Value*>(conditionAny);
    if (!condition->getType()->isIntegerTy(1)) {
        condition = builder->CreateICmpNE(condition,
            llvm::ConstantInt::get(typeRegistry.getIntType(32), 0));
    }

    builder->CreateCondBr(condition, loopBlock, afterBlock);

    // Loop block
    function->getBasicBlockList().push_back(loopBlock);
    builder->SetInsertPoint(loopBlock);
    visit(ctx->body);
    if (!loopBlock->getTerminator()) {
        builder->CreateBr(condBlock);
    }

    // After block
    function->getBasicBlockList().push_back(afterBlock);
    builder->SetInsertPoint(afterBlock);

    return std::any();
}

std::any LLVMCodegen::visitReturnStmt(PrystParser::ReturnStmtContext* ctx) {
    PRYST_DEBUG("Visiting return statement");

    if (!currentFunction) {
        PRYST_ERROR("Return statement outside of function");
        return std::any();
    }

    if (!ctx->value) {
        builder->CreateRetVoid();
        return std::any();
    }

    auto valueAny = visit(ctx->value);
    if (!valueAny.has_value()) {
        return std::any();
    }

    llvm::Value* returnValue = std::any_cast<llvm::Value*>(valueAny);
    if (auto alloca = llvm::dyn_cast<llvm::AllocaInst>(returnValue)) {
        returnValue = builder->CreateLoad(alloca->getAllocatedType(), alloca);
    }

    builder->CreateRet(returnValue);
    return std::any();
}

std::any LLVMCodegen::visitAssignment(PrystParser::AssignmentContext* ctx) {
    PRYST_DEBUG("Visiting assignment: " + ctx->name->getText());

    auto valueAny = visit(ctx->value);
    if (!valueAny.has_value()) {
        return std::any();
    }

    llvm::Value* value = std::any_cast<llvm::Value*>(valueAny);
    auto varName = ctx->name->getText();
    auto var = getVariableValue(varName);
    if (!var) {
        PRYST_ERROR("Unknown variable: " + varName);
        return std::any();
    }

    if (auto alloca = llvm::dyn_cast<llvm::AllocaInst>(var)) {
        if (auto valueAlloca = llvm::dyn_cast<llvm::AllocaInst>(value)) {
            value = builder->CreateLoad(valueAlloca->getAllocatedType(), valueAlloca);
        }
        builder->CreateStore(value, alloca);
        return std::any(value);
    }

    PRYST_ERROR("Invalid assignment target");
    return std::any();
}

std::any LLVMCodegen::visitMemberAccess(PrystParser::MemberAccessContext* ctx) {
    PRYST_DEBUG("Visiting member access");

    auto objectAny = visit(ctx->object);
    if (!objectAny.has_value()) {
        return std::any();
    }

    llvm::Value* object = std::any_cast<llvm::Value*>(objectAny);
    if (auto alloca = llvm::dyn_cast<llvm::AllocaInst>(object)) {
        object = builder->CreateLoad(alloca->getAllocatedType(), alloca);
    }

    auto memberName = ctx->member->getText();
    auto structType = object->getType();
    if (!structType->isStructTy()) {
        PRYST_ERROR("Cannot access member of non-struct type");
        return std::any();
    }

    unsigned memberIndex = typeRegistry.getMemberIndex(structType, memberName);
    auto memberPtr = builder->CreateStructGEP(structType, object, memberIndex);
    return std::any(builder->CreateLoad(memberPtr->getType()->getPointerElementType(), memberPtr));
}

std::any LLVMCodegen::visitStringInterpolation(PrystParser::StringInterpolationContext* ctx) {
    PRYST_DEBUG("Visiting string interpolation");

    std::string result;
    for (size_t i = 0; i < ctx->parts.size(); ++i) {
        auto partAny = visit(ctx->parts[i]);
        if (!partAny.has_value()) {
            continue;
        }

        llvm::Value* part = std::any_cast<llvm::Value*>(partAny);
        if (auto alloca = llvm::dyn_cast<llvm::AllocaInst>(part)) {
            part = builder->CreateLoad(alloca->getAllocatedType(), alloca);
        }

        // Convert part to string if necessary
        if (part->getType()->isIntegerTy()) {
            // Call int_to_str
            auto intToStr = module->getFunction("int_to_str");
            if (!intToStr) {
                PRYST_ERROR("int_to_str function not found");
                return std::any();
            }
            part = builder->CreateCall(intToStr, {part});
        } else if (part->getType()->isFloatingPointTy()) {
            // Call float_to_str
            auto floatToStr = module->getFunction("float_to_str");
            if (!floatToStr) {
                PRYST_ERROR("float_to_str function not found");
                return std::any();
            }
            part = builder->CreateCall(floatToStr, {part});
        }

        // Concatenate strings
        if (i == 0) {
            result = builder->CreateGlobalString(result)->getName().str();
        } else {
            auto concat = module->getFunction("str_concat");
            if (!concat) {
                PRYST_ERROR("str_concat function not found");
                return std::any();
            }
            result = builder->CreateCall(concat, {
                builder->CreateGlobalString(result),
                part
            })->getName().str();
        }
    }

    return std::any(builder->CreateGlobalString(result));
}

std::any LLVMCodegen::visitTypeCast(PrystParser::TypeCastContext* ctx) {
    PRYST_DEBUG("Visiting type cast");

    auto valueAny = visit(ctx->value);
    if (!valueAny.has_value()) {
        return std::any();
    }

    llvm::Value* value = std::any_cast<llvm::Value*>(valueAny);
    if (auto alloca = llvm::dyn_cast<llvm::AllocaInst>(value)) {
        value = builder->CreateLoad(alloca->getAllocatedType(), alloca);
    }

    auto targetType = typeRegistry.getType(ctx->type()->getText());
    if (!targetType) {
        PRYST_ERROR("Unknown type: " + ctx->type()->getText());
        return std::any();
    }

    return std::any(createCastInstruction(value, targetType));
}

} // namespace pryst
