#include "llvm_codegen.hpp"
#include "llvm_utils.hpp"
#include <llvm/IR/Function.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Constants.h>

namespace pryst {

// ... (previous methods remain unchanged) ...

std::any LLVMCodegen::visitStringInterpolation(PrystParser::StringInterpolationContext* ctx) {
    PRYST_DEBUG("Visiting string interpolation");

    // Create a string builder for concatenating parts
    llvm::Value* result = builder->CreateGlobalStringPtr("", "empty_str");

    // Process each part of the string
    for (auto part : ctx->stringPart()) {
        if (auto textPart = dynamic_cast<PrystParser::TextPartContext*>(part)) {
            // Add literal text part
            llvm::Value* text = builder->CreateGlobalStringPtr(textPart->getText(), "text_part");
            result = generateMethodCall(result, "concat", {text});
        } else if (auto exprPart = dynamic_cast<PrystParser::ExprPartContext*>(part)) {
            // Evaluate expression and convert to string
            std::any exprResult = visit(exprPart->expression());
            llvm::Value* exprValue = std::any_cast<llvm::Value*>(exprResult);
            llvm::Value* strValue = convertToString(exprValue);
            result = generateMethodCall(result, "concat", {strValue});
        }
    }

    return result;
}

llvm::Value* LLVMCodegen::convertToString(llvm::Value* value) {
    if (!value) return nullptr;

    llvm::Type* type = value->getType();
    llvm::Value* result = nullptr;

    if (type->isIntegerTy(32)) {
        // Convert int to string
        auto toStringFn = functions["int_toString"];
        if (!toStringFn) {
            throw std::runtime_error("int_toString function not found");
        }
        result = builder->CreateCall(toStringFn, {value}, "int_to_str");
    } else if (type->isDoubleTy()) {
        // Convert float to string
        auto toStringFn = functions["float_toString"];
        if (!toStringFn) {
            throw std::runtime_error("float_toString function not found");
        }
        result = builder->CreateCall(toStringFn, {value}, "float_to_str");
    } else if (type->isIntegerTy(1)) {
        // Convert bool to string
        auto toStringFn = functions["bool_toString"];
        if (!toStringFn) {
            throw std::runtime_error("bool_toString function not found");
        }
        result = builder->CreateCall(toStringFn, {value}, "bool_to_str");
    } else if (type->isPointerTy()) {
        // Already a string, just return it
        result = value;
    } else {
        throw std::runtime_error("Unsupported type for string conversion");
    }

    return result;
}

void LLVMCodegen::declareToStringFunctions() {
    PRYST_DEBUG("Declaring toString functions");

    // Declare int_toString
    auto intToStringType = llvm::FunctionType::get(
        llvm::Type::getInt8PtrTy(*context),
        {llvm::Type::getInt32Ty(*context)},
        false
    );
    functions["int_toString"] = llvm::Function::Create(
        intToStringType,
        llvm::Function::ExternalLinkage,
        "int_toString",
        module.get()
    );

    // Declare float_toString
    auto floatToStringType = llvm::FunctionType::get(
        llvm::Type::getInt8PtrTy(*context),
        {llvm::Type::getDoubleTy(*context)},
        false
    );
    functions["float_toString"] = llvm::Function::Create(
        floatToStringType,
        llvm::Function::ExternalLinkage,
        "float_toString",
        module.get()
    );

    // Declare bool_toString
    auto boolToStringType = llvm::FunctionType::get(
        llvm::Type::getInt8PtrTy(*context),
        {llvm::Type::getInt1Ty(*context)},
        false
    );
    functions["bool_toString"] = llvm::Function::Create(
        boolToStringType,
        llvm::Function::ExternalLinkage,
        "bool_toString",
        module.get()
    );
}

} // namespace pryst
