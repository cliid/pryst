#include "llvm_codegen.hpp"
#include "utils/debug.hpp"
#include <llvm/IR/Verifier.h>
#include <llvm/Support/raw_ostream.h>
#include <sstream>

namespace pryst {

LLVMCodegen::LLVMCodegen()
    : context(std::make_unique<llvm::LLVMContext>()),
      module(std::make_unique<llvm::Module>("pryst_module", *context)),
      builder(std::make_unique<llvm::IRBuilder<>>(*context)),
      typeRegistry(*context),
      currentFunction(nullptr) {
    declarePrintFunctions();
    declareBuiltinFunctions();
}

std::unique_ptr<llvm::Module> LLVMCodegen::generateModule(PrystParser::ProgramContext* ctx) {
    PRYST_DEBUG("Generating module");
    visitProgram(ctx);
    return std::move(module);
}

std::any LLVMCodegen::visitProgram(PrystParser::ProgramContext *ctx) {
    PRYST_DEBUG("Visiting program");
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    for (auto ns : ctx->namespaceDecl()) {
        visit(ns);
    }
    for (auto mod : ctx->moduleDecl()) {
        visit(mod);
    }
    for (auto imp : ctx->importDecl()) {
        visit(imp);
    }
    return nullptr;
}

std::any LLVMCodegen::visitDeclaration(PrystParser::DeclarationContext *ctx) {
    PRYST_DEBUG("Visiting declaration");
    return visitChildren(ctx);
}

std::any LLVMCodegen::visitGlobalUsingDecl(PrystParser::GlobalUsingDeclContext *ctx) {
    PRYST_DEBUG("Visiting global using declaration");
    auto qualifiedId = visit(ctx->qualifiedIdentifier());
    std::string target = std::any_cast<std::string>(qualifiedId);
    if (ctx->MODULE()) {
        activeModules.insert(target);
    } else {
        activeNamespaces.insert(target);
    }
    return nullptr;
}

std::any LLVMCodegen::visitBlockScopedNamespaceDecl(PrystParser::BlockScopedNamespaceDeclContext *ctx) {
    PRYST_DEBUG("Visiting block scoped namespace declaration");
    auto qualifiedId = visit(ctx->qualifiedIdentifier());
    std::string name = std::any_cast<std::string>(qualifiedId);
    currentNamespace.push_back(name);
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    currentNamespace.pop_back();
    return nullptr;
}

std::any LLVMCodegen::visitBlockScopedModuleDecl(PrystParser::BlockScopedModuleDeclContext *ctx) {
    PRYST_DEBUG("Visiting block scoped module declaration");
    auto qualifiedId = visit(ctx->qualifiedIdentifier());
    std::string name = std::any_cast<std::string>(qualifiedId);
    currentModule = name;
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    currentModule.clear();
    return nullptr;
}

std::any LLVMCodegen::visitNamespaceDecl(PrystParser::NamespaceDeclContext *ctx) {
    PRYST_DEBUG("Visiting namespace declaration");
    auto qualifiedId = visit(ctx->qualifiedIdentifier());
    std::string name = std::any_cast<std::string>(qualifiedId);
    currentNamespace.push_back(name);
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    for (auto mod : ctx->moduleDecl()) {
        visit(mod);
    }
    currentNamespace.pop_back();
    return nullptr;
}

std::any LLVMCodegen::visitModuleDecl(PrystParser::ModuleDeclContext *ctx) {
    PRYST_DEBUG("Visiting module declaration");
    auto qualifiedId = visit(ctx->qualifiedIdentifier());
    std::string name = std::any_cast<std::string>(qualifiedId);
    currentModule = name;
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    currentModule.clear();
    return nullptr;
}

std::any LLVMCodegen::visitImportDecl(PrystParser::ImportDeclContext *ctx) {
    PRYST_DEBUG("Visiting import declaration");
    auto importPath = visit(ctx->importPath());
    std::string path = std::any_cast<std::string>(importPath);
    importedModules.insert(path);
    return nullptr;
}

std::any LLVMCodegen::visitImportPath(PrystParser::ImportPathContext *ctx) {
    PRYST_DEBUG("Visiting import path");
    std::string path;
    for (auto id : ctx->IDENTIFIER()) {
        if (!path.empty()) path += "::";
        path += id->getText();
    }
    return path;
}

std::any LLVMCodegen::visitQualifiedIdentifier(PrystParser::QualifiedIdentifierContext *ctx) {
    PRYST_DEBUG("Visiting qualified identifier");
    std::string identifier;
    for (auto id : ctx->IDENTIFIER()) {
        if (!identifier.empty()) identifier += "::";
        identifier += id->getText();
    }
    return identifier;
}

// ... Continue implementing other visitor methods following the same pattern ...

void LLVMCodegen::declarePrintFunctions() {
    PRYST_DEBUG("Declaring print functions");
    // Implementation details...
}

void LLVMCodegen::declareBuiltinFunctions() {
    PRYST_DEBUG("Declaring builtin functions");
    declareBoolToStr();
    declareIntToStr();
    declareFloatToStr();
    declareStrConcat();
    declareMathFunctions();
}

llvm::Function* LLVMCodegen::declareBoolToStr() {
    PRYST_DEBUG("Declaring bool_to_str function");
    std::vector<llvm::Type*> argTypes = {
        llvm::Type::getInt1Ty(*context)
    };
    auto strType = typeRegistry.getStringType();
    auto llvmStrType = typeRegistry.getLLVMType(strType);

    auto funcType = llvm::FunctionType::get(llvmStrType, argTypes, false);
    auto func = llvm::Function::Create(
        funcType,
        llvm::Function::ExternalLinkage,
        "bool_to_str",
        module.get()
    );

    auto entryBlock = llvm::BasicBlock::Create(*context, "entry", func);
    builder->SetInsertPoint(entryBlock);

    auto arg = func->arg_begin();
    auto trueStr = builder->CreateGlobalString("true", "true_str");
    auto falseStr = builder->CreateGlobalString("false", "false_str");

    auto result = builder->CreateSelect(arg, trueStr, falseStr);
    builder->CreateRet(result);

    return func;
}

// ... Continue implementing other helper methods ...

} // namespace pryst
