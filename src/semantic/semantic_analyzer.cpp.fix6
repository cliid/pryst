std::any SemanticAnalyzer::visitQualifiedIdentifier(PrystParser::QualifiedIdentifierContext* ctx) {
    if (!ctx) {
        PRYST_ERROR("Null qualified identifier context");
        throw std::runtime_error("Null qualified identifier context");
    }

    PRYST_DEBUG("Visiting qualified identifier");

    try {
        std::string identifier;
        for (auto id : ctx->IDENTIFIER()) {
            if (!identifier.empty()) {
                identifier += "::";
            }
            identifier += id->getText();
        }

        PRYST_DEBUG("Processing qualified identifier: " + identifier);

        // Check if it's a variable
        if (symbolTable.variableExists(identifier)) {
            PRYST_DEBUG("Found variable: " + identifier);
            return std::any(symbolTable.getVariableType(identifier));
        }

        // Check if it's a function
        if (auto funcInfo = symbolTable.lookupFunction(identifier)) {
            PRYST_DEBUG("Found function: " + identifier);
            return std::any(funcInfo->returnType);
        }

        // Check if it's a module
        if (symbolTable.moduleExists(identifier)) {
            PRYST_DEBUG("Found module: " + identifier);
            return std::any("module");
        }

        // Check if it's a namespace
        if (symbolTable.namespaceExists(identifier)) {
            PRYST_DEBUG("Found namespace: " + identifier);
            return std::any("namespace");
        }

        PRYST_ERROR("Unknown identifier: " + identifier);
        throw std::runtime_error("Unknown identifier: " + identifier);
    } catch (const std::exception& ex) {
        PRYST_ERROR("Error in visitQualifiedIdentifier: " + std::string(ex.what()));
        throw;
    }
}
