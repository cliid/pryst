#include "symbol_table.hpp"
#include <algorithm>
#include <iostream>
#include <sstream>
#include <regex>
#include "logger.hpp"

// Constructor and destructor
SymbolTable::SymbolTable() {
    pushScope();  // Create global scope
    scopes.back()->isGlobalScope = true;
}

SymbolTable::~SymbolTable() {
    while (!scopes.empty()) {
        popScope();
    }
}

// Core scope management
void SymbolTable::pushScope() {
    auto newScope = std::make_shared<Scope>();
    if (!scopes.empty()) {
        newScope->parent = scopes.back();
        scopes.back()->children.push_back(newScope);
    }
    scopes.push_back(newScope);
}

void SymbolTable::popScope() {
    if (scopes.empty()) {
        throw std::runtime_error("No scope to pop");
    }
    auto currentScope = scopes.back();
    if (currentScope->parent) {
        auto& siblings = currentScope->parent->children;
        siblings.erase(std::remove(siblings.begin(), siblings.end(), currentScope), siblings.end());
    }
    currentScope->parent.reset();
    currentScope->children.clear();
    scopes.pop_back();
}

size_t SymbolTable::getCurrentScopeLevel() const {
    return scopes.size() - 1;
}

// Function-related methods
void SymbolTable::addFunction(const std::string& name, std::shared_ptr<FunctionInfo> funcInfo) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto& functions = scopes.back()->functions;
    functions[name].push_back(funcInfo);
}

void SymbolTable::addFunction(const std::string& name, const std::string& returnType, const std::vector<std::string>& paramTypes) {
    auto funcInfo = std::make_shared<FunctionInfo>();
    funcInfo->returnType = returnType;
    funcInfo->parameterTypes = paramTypes;
    addFunction(name, funcInfo);
}

bool SymbolTable::functionExists(const std::string& name) const {
    if (scopes.empty()) return false;
    auto scope = scopes.back();
    while (scope) {
        if (scope->functions.find(name) != scope->functions.end()) {
            return true;
        }
        scope = scope->parent;
    }
    return false;
}

std::vector<std::shared_ptr<FunctionInfo>> SymbolTable::getAllFunctionOverloads(const std::string& name) const {
    if (scopes.empty()) return {};
    auto scope = scopes.back();
    while (scope) {
        auto it = scope->functions.find(name);
        if (it != scope->functions.end()) {
            return it->second;
        }
        scope = scope->parent;
    }
    return {};
}

std::shared_ptr<FunctionInfo> SymbolTable::getFunctionInfo(const std::string& name) const {
    auto overloads = getAllFunctionOverloads(name);
    if (overloads.empty()) {
        throw std::runtime_error("Function not found: " + name);
    }
    return overloads.front();
}

bool SymbolTable::findMatchingFunction(const std::string& name, const std::vector<std::string>& argTypes, std::shared_ptr<FunctionInfo>& outInfo) const {
    auto overloads = getAllFunctionOverloads(name);
    for (const auto& func : overloads) {
        if (func->parameterTypes.size() == argTypes.size()) {
            bool match = true;
            for (size_t i = 0; i < argTypes.size(); ++i) {
                if (!areTypesCompatible(func->parameterTypes[i], argTypes[i])) {
                    match = false;
                    break;
                }
            }
            if (match) {
                outInfo = func;
                return true;
            }
        }
    }
    return false;
}

std::shared_ptr<FunctionInfo> SymbolTable::lookupFunction(const std::string& qualifiedName) const {
    std::vector<std::string> parts;
    std::stringstream ss(qualifiedName);
    std::string part;
    while (std::getline(ss, part, ':')) {
        if (!part.empty()) {
            parts.push_back(part);
        }
    }

    if (parts.empty()) {
        throw std::runtime_error("Invalid qualified name: " + qualifiedName);
    }

    if (parts.size() == 1) {
        return getFunctionInfo(parts[0]);
    }

    // Handle module/namespace qualified names
    std::string currentPart = parts[0];
    auto scope = scopes.back();

    for (size_t i = 0; i < parts.size() - 1; ++i) {
        bool found = false;

        // Check modules
        if (scope->modules.find(currentPart) != scope->modules.end()) {
            auto& moduleInfo = scope->modules[currentPart];
            if (i == parts.size() - 2) {
                auto funcIt = moduleInfo->functions.find(parts.back());
                if (funcIt != moduleInfo->functions.end()) {
                    return funcIt->second;
                }
            }
            found = true;
        }

        // Check namespaces
        if (!found && scope->namespaces.find(currentPart) != scope->namespaces.end()) {
            auto& nsInfo = scope->namespaces[currentPart];
            if (i == parts.size() - 2) {
                auto funcIt = nsInfo->functions.find(parts.back());
                if (funcIt != nsInfo->functions.end()) {
                    return funcIt->second;
                }
            }
            found = true;
        }

        if (!found) {
            throw std::runtime_error("Module/namespace not found: " + currentPart);
        }

        currentPart = parts[i + 1];
    }

    throw std::runtime_error("Function not found: " + qualifiedName);
}

// Variable-related methods
void SymbolTable::addVariable(const std::string& name, const std::string& type, bool isConst) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    if (variableExistsInCurrentScope(name)) {
        throw std::runtime_error("Variable already declared in current scope: " + name);
    }
    VariableInfo info(type, isConst, getCurrentScopeLevel());
    scopes.back()->variables[name] = info;
}

bool SymbolTable::variableExists(const std::string& name) const {
    if (scopes.empty()) return false;
    auto scope = scopes.back();
    while (scope) {
        if (scope->variables.find(name) != scope->variables.end()) {
            return true;
        }
        scope = scope->parent;
    }
    return false;
}

bool SymbolTable::variableExistsInCurrentScope(const std::string& name) const {
    if (scopes.empty()) return false;
    return scopes.back()->variables.find(name) != scopes.back()->variables.end();
}

std::string SymbolTable::getVariableType(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto scope = scopes.back();
    while (scope) {
        auto it = scope->variables.find(name);
        if (it != scope->variables.end()) {
            return it->second.type;
        }
        scope = scope->parent;
    }
    throw std::runtime_error("Variable not found: " + name);
}

std::unordered_map<std::string, VariableInfo> SymbolTable::getCurrentScopeVariables() const {
    if (scopes.empty()) return {};
    return scopes.back()->variables;
}

void SymbolTable::clearCurrentScopeVariables() {
    if (!scopes.empty()) {
        scopes.back()->variables.clear();
    }
}

// Variable capture and scope freezing
void SymbolTable::captureVariable(const std::string& name) {
    PRYST_DEBUG("Attempting to capture variable '" + name + "'");
    if (scopes.empty() || scopes.size() == 1) {
        throw std::runtime_error("No parent scope to capture from");
    }

    auto currentScope = scopes.back();
    if (currentScope->isGlobalScope) {
        throw std::runtime_error("Cannot capture variables in global scope");
    }

    if (currentScope->capturedVariables.find(name) != currentScope->capturedVariables.end()) {
        return;  // Already captured
    }

    auto scope = currentScope->parent;
    while (scope) {
        auto varIt = scope->variables.find(name);
        if (varIt != scope->variables.end()) {
            VariableInfo capturedInfo = varIt->second;
            capturedInfo.isCaptured = true;
            currentScope->capturedVariables[name] = capturedInfo;
            PRYST_DEBUG("Captured variable '" + name + "' of type '" + capturedInfo.type + "'");
            return;
        }
        scope = scope->parent;
    }

    throw std::runtime_error("Variable '" + name + "' not found in parent scopes");
}

void SymbolTable::validateVariableAccess(const std::string& name) const {
    PRYST_DEBUG("Validating access to variable '" + name + "'");
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }

    auto currentScope = scopes.back();
    if (currentScope->variables.find(name) != currentScope->variables.end()) {
        return;  // Variable is in current scope
    }

    if (currentScope->capturedVariables.find(name) != currentScope->capturedVariables.end()) {
        return;  // Variable is captured
    }

    if (currentScope->isFrozen) {
        throw std::runtime_error("Cannot access non-captured variable '" + name + "' in frozen scope");
    }

    auto scope = currentScope->parent;
    while (scope) {
        if (scope->variables.find(name) != scope->variables.end()) {
            if (currentScope->isFrozen) {
                throw std::runtime_error("Cannot access non-captured variable '" + name + "' in frozen scope");
            }
            return;
        }
        scope = scope->parent;
    }

    throw std::runtime_error("Undefined variable: '" + name + "'");
}

void SymbolTable::freezeScope() {
    PRYST_DEBUG("Freezing current scope");
    if (scopes.empty()) {
        throw std::runtime_error("No active scope to freeze");
    }
    scopes.back()->isFrozen = true;
}

bool SymbolTable::isVariableCaptured(const std::string& name) const {
    if (scopes.empty()) return false;
    return scopes.back()->capturedVariables.find(name) != scopes.back()->capturedVariables.end();
}

VariableInfo SymbolTable::getCapturedVariable(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }

    auto currentScope = scopes.back();
    auto it = currentScope->capturedVariables.find(name);
    if (it == currentScope->capturedVariables.end()) {
        throw std::runtime_error("Variable '" + name + "' is not captured in current scope");
    }

    return it->second;
}

bool SymbolTable::isScopeFrozen() const {
    if (scopes.empty()) return false;
    return scopes.back()->isFrozen;
}

// Class-related methods
void SymbolTable::addClass(const std::string& name, const std::string& parentClass) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    if (classExists(name)) {
        throw std::runtime_error("Class already exists: " + name);
    }
    ClassInfo info;
    info.name = name;
    info.parentClass = parentClass;
    scopes.back()->classes[name] = info;
}

void SymbolTable::addClass(const std::string& name, const ClassInfo& info) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    if (classExists(name)) {
        throw std::runtime_error("Class already exists: " + name);
    }
    scopes.back()->classes[name] = info;
}

bool SymbolTable::classExists(const std::string& name) const {
    if (scopes.empty()) return false;
    auto scope = scopes.back();
    while (scope) {
        if (scope->classes.find(name) != scope->classes.end()) {
            return true;
        }
        scope = scope->parent;
    }
    return false;
}

ClassInfo SymbolTable::getClassInfo(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto scope = scopes.back();
    while (scope) {
        auto it = scope->classes.find(name);
        if (it != scope->classes.end()) {
            return it->second;
        }
        scope = scope->parent;
    }
    throw std::runtime_error("Class not found: " + name);
}

std::unordered_map<std::string, ClassInfo> SymbolTable::getCurrentScopeClasses() const {
    if (scopes.empty()) return {};
    return scopes.back()->classes;
}

// Module-related methods
void SymbolTable::addModule(const std::string& name, const ModuleInfo& info) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    if (moduleExists(name)) {
        throw std::runtime_error("Module already exists: " + name);
    }
    auto moduleInfo = std::make_shared<ModuleInfo>(info);
    scopes.back()->modules[name] = moduleInfo;
}

bool SymbolTable::moduleExists(const std::string& name) const {
    if (scopes.empty()) return false;
    auto scope = scopes.back();
    while (scope) {
        if (scope->modules.find(name) != scope->modules.end()) {
            return true;
        }
        scope = scope->parent;
    }
    return false;
}

ModuleInfo SymbolTable::getModuleInfo(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto scope = scopes.back();
    while (scope) {
        auto it = scope->modules.find(name);
        if (it != scope->modules.end()) {
            return *it->second;
        }
        scope = scope->parent;
    }
    throw std::runtime_error("Module not found: " + name);
}

std::string SymbolTable::getCurrentModule() const {
    return currentModule;
}

void SymbolTable::setCurrentModule(const std::string& moduleName) {
    currentModule = moduleName;
}

std::string SymbolTable::getCurrentNamespacePath() const {
    return currentNamespacePath;
}

void SymbolTable::setCurrentNamespacePath(const std::string& namespacePath) {
    currentNamespacePath = namespacePath;
}

void SymbolTable::addImport(const std::string& qualifiedName) {
    imports.push_back(qualifiedName);
}

// Namespace-related methods
void SymbolTable::addNamespace(const std::string& name) {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    if (namespaceExists(name)) {
        throw std::runtime_error("Namespace already exists: " + name);
    }
    auto nsInfo = std::make_shared<NamespaceInfo>();
    nsInfo->name = name;
    scopes.back()->namespaces[name] = nsInfo;
}

bool SymbolTable::namespaceExists(const std::string& name) const {
    if (scopes.empty()) return false;
    auto scope = scopes.back();
    while (scope) {
        if (scope->namespaces.find(name) != scope->namespaces.end()) {
            return true;
        }
        scope = scope->parent;
    }
    return false;
}

std::shared_ptr<NamespaceInfo> SymbolTable::getNamespaceInfo(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto scope = scopes.back();
    while (scope) {
        auto it = scope->namespaces.find(name);
        if (it != scope->namespaces.end()) {
            return it->second;
        }
        scope = scope->parent;
    }
    throw std::runtime_error("Namespace not found: " + name);
}

// Helper methods
bool SymbolTable::areTypesCompatible(const std::string& expected, const std::string& actual) const {
    if (expected == actual) return true;
    if (expected == "float" && actual == "int") return true;
    if (expected == "any") return true;

    // Handle function types
    if (isFunctionType(expected) && isFunctionType(actual)) {
        auto [expectedReturn, expectedParams] = parseFunctionType(expected);
        auto [actualReturn, actualParams] = parseFunctionType(actual);

        if (!areTypesCompatible(expectedReturn, actualReturn)) return false;
        if (expectedParams.size() != actualParams.size()) return false;

        for (size_t i = 0; i < expectedParams.size(); ++i) {
            if (!areTypesCompatible(expectedParams[i], actualParams[i])) return false;
        }
        return true;
    }

    return false;
}

bool SymbolTable::isFunctionType(const std::string& type) const {
    return type.find("fn<") == 0;
}

std::pair<std::string, std::vector<std::string>> SymbolTable::parseFunctionType(const std::string& type) const {
    std::regex functionTypeRegex(R"(fn<([^>]+)>\((.*)\))");
    std::smatch matches;

    if (std::regex_match(type, matches, functionTypeRegex)) {
        std::string returnType = matches[1];
        std::string paramsStr = matches[2];

        std::vector<std::string> paramTypes;
        if (!paramsStr.empty()) {
            std::stringstream ss(paramsStr);
            std::string param;
            while (std::getline(ss, param, ',')) {
                // Trim whitespace
                param.erase(0, param.find_first_not_of(" "));
                param.erase(param.find_last_not_of(" ") + 1);
                paramTypes.push_back(param);
            }
        }

        return {returnType, paramTypes};
    }

    throw std::runtime_error("Invalid function type format: " + type);
}

std::string SymbolTable::createFunctionTypeString(const std::string& returnType, const std::vector<std::string>& paramTypes) const {
    std::string result = "fn<" + returnType + ">(";
    for (size_t i = 0; i < paramTypes.size(); ++i) {
        if (i > 0) result += ", ";
        result += paramTypes[i];
    }
    result += ")";
    return result;
}
