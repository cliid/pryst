#include "semantic_analyzer.hpp"
#include "module_loader.hpp"
#include "../codegen/type_registry.hpp"
#include "../utils/logger.hpp"
#include <stdexcept>
#include <iostream>
#include <algorithm>
#include <regex>

std::string SemanticAnalyzer::constructFunctionTypeString(const std::string& returnType, const std::vector<std::string>& paramTypes) {
    std::string typeStr = "fn<" + returnType + ">";
    for (const auto& paramType : paramTypes) {
        typeStr += "(" + paramType + ")";
    }
    return typeStr;
}

std::any SemanticAnalyzer::visitPrimary(PrystParser::PrimaryContext* ctx) {
    if (!ctx) {
        PRYST_ERROR("Null primary context");
        throw std::runtime_error("Null primary context");
    }

    PRYST_DEBUG("Visiting primary expression");

    try {
        if (ctx->TRUE() || ctx->FALSE()) {
            PRYST_DEBUG("Processing boolean literal");
            return std::any(std::string("bool"));
        }

        if (ctx->NULL_()) {
            PRYST_DEBUG("Processing null literal");
            return std::any(std::string("null"));
        }

        if (ctx->NUMBER()) {
            PRYST_DEBUG("Processing number literal");
            if (!ctx->NUMBER()->getText().empty()) {
                std::string numStr = ctx->NUMBER()->getText();
                return std::any(std::string(numStr.find('.') != std::string::npos ? "float" : "int"));
            }
            throw std::runtime_error("Invalid number literal");
        }

        if (ctx->STRING()) {
            PRYST_DEBUG("Processing string literal");
            std::string str = ctx->STRING()->getText();
            // Remove quotes
            str = str.substr(1, str.length() - 2);

            // Check for string interpolation
            std::regex interpolationPattern("\\{([^}]+)\\}");
            if (std::regex_search(str, interpolationPattern)) {
                PRYST_DEBUG("Found string interpolation pattern");
                std::smatch match;
                std::string::const_iterator searchStart(str.cbegin());
                while (std::regex_search(searchStart, str.cend(), match, interpolationPattern)) {
                    std::string expr = match[1].str();
                    PRYST_DEBUG("Checking interpolated expression: " + expr);

                    size_t formatPos = expr.find(':');
                    std::string varName = formatPos != std::string::npos ? expr.substr(0, formatPos) : expr;
                    std::string formatSpec = formatPos != std::string::npos ? expr.substr(formatPos + 1) : "";

                    if (!symbolTable.variableExists(varName)) {
                        PRYST_ERROR("Unknown variable in string interpolation: " + varName);
                        throw std::runtime_error("Unknown variable in string interpolation: " + varName);
                    }

                    std::string varType = symbolTable.getVariableType(varName);
                    PRYST_DEBUG("Variable type in interpolation: " + varType);

                    if (!formatSpec.empty() && formatSpec.find('f') != std::string::npos && varType != "float") {
                        PRYST_ERROR("Format specifier 'f' can only be used with float type");
                        throw std::runtime_error("Format specifier 'f' can only be used with float type");
                    }

                    searchStart = match.suffix().first;
                }
            }
            return std::any(std::string("str"));
        }

        if (ctx->qualifiedIdentifier()) {
            if (!ctx->qualifiedIdentifier()->getText().empty()) {
                std::string name = ctx->qualifiedIdentifier()->getText();
                PRYST_DEBUG("Processing qualified identifier: " + name);

                // First check if it's a variable
                if (symbolTable.variableExists(name)) {
                    PRYST_DEBUG("Found variable: " + name);
                    std::string varType = symbolTable.getVariableType(name);
                    PRYST_DEBUG("Variable type: " + varType);

                    try {
                        // If it's a function call, check if the variable is a lambda function
                        if (ctx->LPAREN() && varType.length() >= 3 && varType.substr(0, 3) == "fn<") {
                            PRYST_DEBUG("Processing lambda function call");
                            // Parse the lambda function type to get return and param types
                            size_t returnTypeStart = 3;
                            size_t returnTypeEnd = varType.find('>', returnTypeStart);
                            if (returnTypeEnd == std::string::npos) {
                                throw std::runtime_error("Invalid lambda function type: " + varType);
                            }
                            std::string returnType = varType.substr(returnTypeStart, returnTypeEnd - returnTypeStart);
                            PRYST_DEBUG("Lambda return type: " + returnType);

                            // Extract parameter types
                            std::vector<std::string> paramTypes;
                            size_t pos = returnTypeEnd + 1;
                            while (pos < varType.length()) {
                                if (varType[pos] == '(') {
                                    size_t end = varType.find(')', pos);
                                    if (end == std::string::npos) break;
                                    std::string paramType = varType.substr(pos + 1, end - pos - 1);
                                    PRYST_DEBUG("Found parameter type: " + paramType);
                                    paramTypes.push_back(paramType);
                                    pos = end + 1;
                                } else {
                                    pos++;
                                }
                            }

                            // Check argument count
                            size_t actualArgs = ctx->arguments() ? ctx->arguments()->expression().size() : 0;
                            PRYST_DEBUG("Checking argument count: expected=" + std::to_string(paramTypes.size()) +
                                      ", actual=" + std::to_string(actualArgs));
                            if (actualArgs != paramTypes.size()) {
                                throw std::runtime_error("Wrong number of arguments for lambda function " + name +
                                                      ". Expected " + std::to_string(paramTypes.size()) +
                                                      ", got " + std::to_string(actualArgs));
                            }

                            // Check argument types
                            if (ctx->arguments()) {
                                PRYST_DEBUG("Checking argument types");
                                for (size_t i = 0; i < actualArgs; i++) {
                                    auto expr = ctx->arguments()->expression(i);
                                    if (!expr) {
                                        throw std::runtime_error("Null expression in argument " + std::to_string(i + 1));
                                    }
                                    auto argResult = visit(expr);
                                    std::string argType = std::any_cast<std::string>(argResult);
                                    PRYST_DEBUG("Argument " + std::to_string(i + 1) + " type: " + argType);
                                    checkTypes(paramTypes[i], argType,
                                             "Type mismatch in argument " + std::to_string(i + 1) +
                                             " of lambda function " + name);
                                }
                            }

                            PRYST_DEBUG("Lambda function call validated, returning type: " + returnType);
                            return std::any(returnType);
                        }
                    } catch (const std::exception& e) {
                        PRYST_DEBUG("Error processing lambda function: " + std::string(e.what()));
                        throw;
                    }
                    return std::any(varType);
                }

                // If not a variable, check if it's a regular function call
                if (ctx->LPAREN()) {
                    PRYST_DEBUG("Looking up function: " + name);
                    auto funcInfo = symbolTable.lookupFunction(name);
                    if (!funcInfo) {
                        throw std::runtime_error("Unknown function: " + name);
                    }

                    // Check argument count
                    size_t expectedArgs = funcInfo->paramTypes.size();
                    size_t actualArgs = 0;

                    if (ctx->arguments()) {
                        actualArgs = ctx->arguments()->expression().size();
                    }
                    PRYST_DEBUG("Checking function arguments: expected=" + std::to_string(expectedArgs) +
                               ", actual=" + std::to_string(actualArgs));

                    if (actualArgs != expectedArgs) {
                        throw std::runtime_error("Wrong number of arguments for function " + name +
                                               ". Expected " + std::to_string(expectedArgs) +
                                               ", got " + std::to_string(actualArgs));
                    }

                    // Check argument types
                    if (ctx->arguments()) {
                        PRYST_DEBUG("Checking function argument types");
                        for (size_t i = 0; i < actualArgs; i++) {
                            auto expr = ctx->arguments()->expression(i);
                            if (!expr) {
                                throw std::runtime_error("Null expression in argument " + std::to_string(i + 1));
                            }
                            auto argResult = visit(expr);
                            std::string argType = std::any_cast<std::string>(argResult);
                            PRYST_DEBUG("Function argument " + std::to_string(i + 1) + " type: " + argType);
                            checkTypes(funcInfo->paramTypes[i], argType,
                                     "Type mismatch in argument " + std::to_string(i + 1) +
                                     " of function " + name);
                        }
                    }

                    PRYST_DEBUG("Function call validated, returning type: " + funcInfo->returnType);
                    return std::any(funcInfo->returnType);
                }

                throw std::runtime_error("Unknown identifier: " + name);
            }
            throw std::runtime_error("Empty qualified identifier");
        } else if (ctx->LPAREN() && ctx->expression()) {
            PRYST_DEBUG("Processing parenthesized expression");
            return visit(ctx->expression());
        } else if (ctx->SUPER()) {
            throw std::runtime_error("'super' keyword not implemented");
        } else if (ctx->newExpression()) {
            PRYST_DEBUG("Processing new expression");
            return visit(ctx->newExpression());
        }

        throw std::runtime_error("Invalid primary expression");
    } catch (const std::exception& ex) {
        PRYST_ERROR("Error in visitPrimary: " + std::string(ex.what()));
        throw;
    }
}
