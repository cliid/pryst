// Add getExpressionType and getReturnTypeFromBody methods to SemanticAnalyzer class
std::string SemanticAnalyzer::getExpressionType(PrystParser::ExpressionContext* ctx) {
    if (!ctx) return "void";

    // Handle different expression types
    if (auto* numberCtx = dynamic_cast<PrystParser::NumberContext*>(ctx)) {
        // Check if it's a float or int
        std::string numText = numberCtx->getText();
        return numText.find('.') != std::string::npos ? "float" : "int";
    }

    if (auto* stringCtx = dynamic_cast<PrystParser::StringContext*>(ctx)) {
        return "string";
    }

    if (auto* boolCtx = dynamic_cast<PrystParser::BoolContext*>(ctx)) {
        return "bool";
    }

    if (auto* identifierCtx = dynamic_cast<PrystParser::IdentifierContext*>(ctx)) {
        std::string varName = identifierCtx->getText();
        if (auto varType = symbolTable.getVariableType(varName)) {
            return *varType;
        }
    }

    if (auto* callCtx = dynamic_cast<PrystParser::CallContext*>(ctx)) {
        std::string funcName = callCtx->IDENTIFIER()->getText();
        if (auto funcInfo = symbolTable.getFunctionInfo(funcName)) {
            return funcInfo->returnType;
        }
    }

    if (auto* lambdaCtx = dynamic_cast<PrystParser::LambdaFunctionContext*>(ctx)) {
        auto lambdaInfo = std::any_cast<LambdaInfo>(visitLambdaFunction(lambdaCtx));
        return lambdaInfo.returnType;
    }

    if (auto* unaryCtx = dynamic_cast<PrystParser::UnaryContext*>(ctx)) {
        std::string operatorType = unaryCtx->op->getText();
        if (operatorType == "!") {
            return "bool";
        }
        return getExpressionType(unaryCtx->expression());
    }

    if (auto* postfixCtx = dynamic_cast<PrystParser::PostfixContext*>(ctx)) {
        // Handle member access
        if (postfixCtx->DOT()) {
            std::string baseType = getExpressionType(postfixCtx->primary());
            std::string memberName = postfixCtx->IDENTIFIER()->getText();
            return getMemberVariableType(baseType, memberName);
        }
        return getExpressionType(postfixCtx->primary());
    }

    // Handle binary operations
    if (auto* binaryOpCtx = dynamic_cast<PrystParser::BinaryOperationContext*>(ctx)) {
        std::string leftType = getExpressionType(binaryOpCtx->left);
        std::string rightType = getExpressionType(binaryOpCtx->right);
        std::string op = binaryOpCtx->op->getText();

        // Comparison operators
        if (op == "==" || op == "!=" || op == "<" || op == "<=" || op == ">" || op == ">=") {
            return "bool";
        }

        // Arithmetic operators
        if (leftType == "float" || rightType == "float") {
            return "float";
        }
        return "int";
    }

    // Default to void if type cannot be determined
    return "void";
}

std::string SemanticAnalyzer::getReturnTypeFromBody(const std::vector<PrystParser::DeclarationContext*>& declarations) {
    std::string inferredType = "void";
    bool hasReturn = false;

    for (auto* decl : declarations) {
        // Check if it's a return statement
        if (auto* returnStmt = dynamic_cast<PrystParser::ReturnStatementContext*>(decl)) {
            hasReturn = true;
            if (returnStmt->expression()) {
                std::string exprType = getExpressionType(returnStmt->expression());
                if (inferredType == "void") {
                    inferredType = exprType;
                } else if (inferredType != exprType) {
                    // If we have conflicting return types, prefer the more general type
                    if (inferredType == "int" && exprType == "float") {
                        inferredType = "float";
                    }
                    // Could add more type promotion rules here
                }
            }
        }
    }

    return hasReturn ? inferredType : "void";
}
