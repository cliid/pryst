#include "symbol_table.hpp"
#include <algorithm>
#include <iostream>

SymbolTable::SymbolTable() {
    std::cout << "DEBUG: Initializing SymbolTable" << std::endl;
    pushScope();  // Initialize with global scope
}

void SymbolTable::pushScope() {
    scopes.push_back(Scope());
    std::cout << "DEBUG: Pushed scope, new level: " << getCurrentScopeLevel() << std::endl;
}

void SymbolTable::popScope() {
    if (scopes.empty()) {
        std::cout << "DEBUG: ERROR - Attempting to pop empty scope stack" << std::endl;
        throw std::runtime_error("Cannot pop empty scope stack");
    }
    if (scopes.size() == 1) {
        std::cout << "DEBUG: ERROR - Attempting to pop global scope" << std::endl;
        throw std::runtime_error("Cannot pop global scope");
    }

    // Remove variables declared in the current scope
    for (auto it = scopes.back().variables.begin(); it != scopes.back().variables.end();) {
        std::cout << "DEBUG: Removing variable '" << it->first << "' from scope " << getCurrentScopeLevel() << std::endl;
        it = scopes.back().variables.erase(it);
    }

    // Remove functions declared in the current scope
    for (auto it = scopes.back().functions.begin(); it != scopes.back().functions.end();) {
        std::cout << "DEBUG: Removing function '" << it->first << "' from scope " << getCurrentScopeLevel() << std::endl;
        it = scopes.back().functions.erase(it);
    }

    scopes.pop_back();
    std::cout << "DEBUG: Popped scope, new level: " << getCurrentScopeLevel() << std::endl;
}

size_t SymbolTable::getCurrentScopeLevel() const {
    return scopes.size() - 1;
}

bool SymbolTable::variableExists(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->variables.find(name) != it->variables.end()) {
            return true;
        }
    }
    return false;
}

bool SymbolTable::variableExistsInCurrentScope(const std::string& name) const {
    if (scopes.empty()) return false;
    return scopes.back().variables.find(name) != scopes.back().variables.end();
}

void SymbolTable::addVariable(const std::string& name, const std::string& type, bool isConst) {
    std::cout << "DEBUG: Adding variable '" << name << "' of type '" << type << "' to scope " << getCurrentScopeLevel() << std::endl;
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    scopes.back().variables[name] = {type, isConst, static_cast<int>(getCurrentScopeLevel())};
}

std::string SymbolTable::getVariableType(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        auto var = it->variables.find(name);
        if (var != it->variables.end()) {
            return var->second.type;
        }
    }
    throw std::runtime_error("Undefined variable: '" + name + "'");
}

std::unordered_map<std::string, SymbolTable::VariableInfo> SymbolTable::getCurrentScopeVariables() const {
    if (scopes.empty()) return {};
    std::unordered_map<std::string, VariableInfo> result;
    for (const auto& pair : scopes.back().variables) {
        result.insert(pair);
    }
    return result;
}

void SymbolTable::clearCurrentScopeVariables() {
    if (!scopes.empty()) {
        scopes.back().variables.clear();
    }
}

bool SymbolTable::functionExists(const std::string& name) const {
    if (scopes.empty()) return false;
    return scopes[0].functions.find(name) != scopes[0].functions.end() &&
           !scopes[0].functions.at(name).empty();
}

void SymbolTable::addFunction(const std::string& name, const std::string& returnType, const std::vector<std::string>& paramTypes) {
    std::cout << "DEBUG: Adding function '" << name << "' with return type '" << returnType << "' to scope " << getCurrentScopeLevel() << std::endl;
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    FunctionInfo info{returnType, paramTypes, static_cast<int>(getCurrentScopeLevel())};
    scopes[0].functions[name].push_back(info);
}

std::vector<SymbolTable::FunctionInfo> SymbolTable::getAllFunctionOverloads(const std::string& name) const {
    if (scopes.empty() || !functionExists(name)) {
        return {};
    }
    return scopes[0].functions.at(name);
}

SymbolTable::FunctionInfo SymbolTable::getFunctionInfo(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto it = scopes[0].functions.find(name);
    if (it == scopes[0].functions.end() || it->second.empty()) {
        throw std::runtime_error("Undefined function: '" + name + "'");
    }
    return it->second[0];  // Return first overload by default
}

std::unordered_map<std::string, SymbolTable::FunctionInfo> SymbolTable::getCurrentScopeFunctions() const {
    if (scopes.empty()) {
        return {};
    }
    std::unordered_map<std::string, FunctionInfo> result;
    for (const auto& func : scopes.back().functions) {
        if (!func.second.empty()) {
            result[func.first] = func.second[0]; // Get first overload
        }
    }
    return result;
}

void SymbolTable::clearCurrentScopeFunctions() {
    if (!scopes.empty()) {
        scopes.back().functions.clear();
    }
}

bool SymbolTable::classExists(const std::string& name) const {
    if (scopes.empty()) return false;
    return scopes[0].classes.find(name) != scopes[0].classes.end();
}

void SymbolTable::addClass(const std::string& name, const std::string& parentClass) {
    std::cout << "DEBUG: Adding class '" << name << "' with parent '" << parentClass << "'" << std::endl;
    if (classExists(name)) {
        throw std::runtime_error("Class '" + name + "' already declared");
    }
    ClassInfo info;
    info.superClassName = parentClass;
    scopes[0].classes[name] = info;
}

SymbolTable::ClassInfo SymbolTable::getClassInfo(const std::string& name) const {
    if (scopes.empty()) {
        throw std::runtime_error("No active scope");
    }
    auto it = scopes[0].classes.find(name);
    if (it == scopes[0].classes.end()) {
        throw std::runtime_error("Undefined class: '" + name + "'");
    }
    return it->second;
}

bool SymbolTable::areTypesCompatible(const std::string& expected, const std::string& actual) const {
    if (expected == actual) return true;
    // Allow implicit conversion between numeric types
    if ((expected == "int" || expected == "float") && (actual == "int" || actual == "float")) {
        return true;
    }
    return false;
}
