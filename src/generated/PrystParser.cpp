
// Generated from /home/ubuntu/pryst-workspace/pryst-cpp/src/PrystParser.g4 by ANTLR 4.13.1


#include "PrystParserVisitor.h"

#include "PrystParser.h"


using namespace antlrcpp;
using namespace pryst;

using namespace antlr4;

namespace {

struct PrystParserStaticData final {
  PrystParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  PrystParserStaticData(const PrystParserStaticData&) = delete;
  PrystParserStaticData(PrystParserStaticData&&) = delete;
  PrystParserStaticData& operator=(const PrystParserStaticData&) = delete;
  PrystParserStaticData& operator=(PrystParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag prystparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
PrystParserStaticData *prystparserParserStaticData = nullptr;

void prystparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (prystparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(prystparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<PrystParserStaticData>(
    std::vector<std::string>{
      "program", "moduleDecl", "importDecl", "importPath", "declaration", 
      "errorDecl", "functionDecl", "parameters", "parameter", "defaultParam", 
      "literal", "block", "statement", "varDecl", "identifierList", "assignment", 
      "ifStmt", "whileStmt", "forStmt", "returnStmt", "tryStmt", "catchClause", 
      "breakStmt", "continueStmt", "printStmt", "expressionStmt", "classDecl", 
      "interfaceDecl", "interfaceMember", "genericParams", "genericArgs", 
      "classMember", "overloadParams", "constructorDecl", "constructorBlock", 
      "type", "typeRest", "primaryType", "qualifiedType", "returnType", 
      "nullableType", "basicType", "arrayType", "mapType", "keyType", "functionType", 
      "typeList", "expression", "primary", "stringInterpolation", "chainedCall", 
      "stringLiteral", "lambdaParams", "arguments", "arrayLiteral", "mapLiteral", 
      "mapEntry", "mapKey", "errorMember"
    },
    std::vector<std::string>{
      "", "", "", "", "'int'", "'float'", "'bool'", "'str'", "'void'", "'fn'", 
      "'let'", "'const'", "'const!'", "'class'", "'interface'", "'extends'", 
      "'implements'", "'return'", "'if'", "'else'", "'while'", "'for'", 
      "'in'", "'import'", "'module'", "'try'", "'catch'", "'finally'", "'as'", 
      "'break'", "'continue'", "'new'", "'map'", "'from'", "'this'", "'null'", 
      "'instanceof'", "'typeof'", "'error'", "'chain'", "'print'", "'\\u003F\\u003F'", 
      "", "", "", "", "'%'", "'='", "'=='", "'!='", "'<'", "'>'", "'<='", 
      "'>='", "'&&'", "'||'", "'!'", "'|'", "'&'", "'\\u003F'", "':'", "'->'", 
      "'++'", "'--'", "", "", "'{'", "'}'", "'['", "']'", "';'", "", "", 
      "'::'"
    },
    std::vector<std::string>{
      "", "INTEGER", "FLOAT_LITERAL", "BOOLEAN", "INT", "FLOAT", "BOOL", 
      "STR", "VOID", "FN", "LET", "CONST", "CONST_EXPR", "CLASS", "INTERFACE", 
      "EXTENDS", "IMPLEMENTS", "RETURN", "IF", "ELSE", "WHILE", "FOR", "IN", 
      "IMPORT", "MODULE", "TRY", "CATCH", "FINALLY", "AS", "BREAK", "CONTINUE", 
      "NEW", "MAP", "FROM", "THIS", "NULL_LIT", "INSTANCEOF", "TYPEOF", 
      "ERROR", "CHAIN", "PRINT", "NULL_COALESCE", "PLUS", "MINUS", "STAR", 
      "SLASH", "PERCENT", "ASSIGN", "EQ", "NEQ", "LT", "GT", "LE", "GE", 
      "AND", "OR", "NOT", "PIPE", "AMP", "QUESTION_MARK", "COLON", "ARROW", 
      "INC", "DEC", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", 
      "SEMICOLON", "COMMA", "DOT", "DOUBLE_COLON", "IDENTIFIER", "STRING", 
      "STRING_START", "STRING_MIDDLE", "STRING_END", "WS", "COMMENT", "BLOCK_COMMENT", 
      "INVALID_CHAR", "INVALID_IDENTIFIER", "INTERP_WS"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,84,912,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,1,0,5,0,120,8,0,10,0,12,0,123,9,0,1,0,5,0,126,
  	8,0,10,0,12,0,129,9,0,1,0,5,0,132,8,0,10,0,12,0,135,9,0,1,0,1,0,1,1,1,
  	1,1,1,1,1,5,1,143,8,1,10,1,12,1,146,9,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,
  	2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,5,2,166,8,2,10,2,12,2,169,9,
  	2,1,2,1,2,3,2,173,8,2,1,3,1,3,1,3,5,3,178,8,3,10,3,12,3,181,9,3,1,4,1,
  	4,1,4,1,4,1,4,1,4,3,4,189,8,4,1,5,1,5,1,5,1,5,3,5,195,8,5,1,5,1,5,1,5,
  	5,5,200,8,5,10,5,12,5,203,9,5,1,5,1,5,1,6,1,6,1,6,3,6,210,8,6,1,6,1,6,
  	3,6,214,8,6,1,6,1,6,1,6,1,7,1,7,1,7,5,7,222,8,7,10,7,12,7,225,9,7,1,7,
  	1,7,5,7,229,8,7,10,7,12,7,232,9,7,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,3,9,
  	242,8,9,1,10,1,10,1,11,1,11,5,11,248,8,11,10,11,12,11,251,9,11,1,11,1,
  	11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,267,
  	8,12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
  	1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,293,8,13,
  	1,13,1,13,3,13,297,8,13,1,14,1,14,1,14,5,14,302,8,14,10,14,12,14,305,
  	9,14,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,
  	319,8,16,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,18,3,18,331,8,
  	18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,344,8,
  	18,1,18,3,18,347,8,18,1,18,1,18,3,18,351,8,18,1,18,1,18,3,18,355,8,18,
  	1,19,1,19,3,19,359,8,19,1,19,1,19,1,20,1,20,1,20,5,20,366,8,20,10,20,
  	12,20,369,9,20,1,20,1,20,3,20,373,8,20,1,21,1,21,1,21,1,21,1,21,1,21,
  	3,21,381,8,21,1,21,1,21,1,21,1,22,1,22,1,22,1,23,1,23,1,23,1,24,1,24,
  	1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,26,1,26,1,26,3,26,404,8,26,1,26,
  	1,26,1,26,3,26,409,8,26,3,26,411,8,26,1,26,1,26,1,26,3,26,416,8,26,1,
  	26,1,26,1,26,3,26,421,8,26,5,26,423,8,26,10,26,12,26,426,9,26,3,26,428,
  	8,26,1,26,1,26,1,26,5,26,433,8,26,10,26,12,26,436,9,26,1,26,1,26,1,27,
  	1,27,1,27,3,27,443,8,27,1,27,1,27,1,27,3,27,448,8,27,1,27,1,27,1,27,3,
  	27,453,8,27,5,27,455,8,27,10,27,12,27,458,9,27,3,27,460,8,27,1,27,1,27,
  	5,27,464,8,27,10,27,12,27,467,9,27,1,27,1,27,1,28,1,28,1,28,1,28,3,28,
  	475,8,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,484,8,28,1,29,1,29,1,
  	29,1,29,5,29,490,8,29,10,29,12,29,493,9,29,1,29,1,29,1,30,1,30,1,30,1,
  	30,5,30,501,8,30,10,30,12,30,504,9,30,1,30,1,30,1,31,3,31,509,8,31,1,
  	31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,518,8,31,1,31,1,31,3,31,522,8,31,
  	1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,531,8,31,1,31,1,31,1,31,3,31,
  	536,8,31,1,32,1,32,1,32,5,32,541,8,32,10,32,12,32,544,9,32,1,33,1,33,
  	1,33,3,33,549,8,33,1,33,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
  	1,34,1,34,5,34,563,8,34,10,34,12,34,566,9,34,1,34,1,34,1,35,1,35,5,35,
  	572,8,35,10,35,12,35,575,9,35,1,36,1,36,1,36,1,36,3,36,581,8,36,1,37,
  	1,37,1,37,3,37,586,8,37,1,37,1,37,1,37,1,37,3,37,592,8,37,1,38,1,38,1,
  	38,5,38,597,8,38,10,38,12,38,600,9,38,1,39,1,39,3,39,604,8,39,1,40,1,
  	40,1,40,1,40,1,40,3,40,611,8,40,1,40,1,40,1,41,1,41,1,42,1,42,1,42,1,
  	42,1,42,1,42,1,42,1,42,5,42,625,8,42,10,42,12,42,628,9,42,1,43,1,43,1,
  	43,1,43,1,43,1,43,1,43,1,44,1,44,1,45,1,45,1,45,1,45,1,45,1,45,3,45,645,
  	8,45,1,45,1,45,1,46,1,46,1,46,5,46,652,8,46,10,46,12,46,655,9,46,1,47,
  	1,47,1,47,1,47,1,47,3,47,662,8,47,1,47,1,47,3,47,666,8,47,1,47,1,47,1,
  	47,1,47,1,47,3,47,673,8,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,
  	47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,691,8,47,1,47,1,47,1,47,1,
  	47,1,47,1,47,3,47,699,8,47,3,47,701,8,47,1,47,1,47,1,47,1,47,1,47,1,47,
  	1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,
  	1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,
  	1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,747,8,47,1,47,
  	1,47,3,47,751,8,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,759,8,47,1,47,1,
  	47,3,47,763,8,47,1,47,1,47,1,47,1,47,1,47,1,47,4,47,771,8,47,11,47,12,
  	47,772,1,47,1,47,1,47,1,47,5,47,779,8,47,10,47,12,47,782,9,47,1,48,1,
  	48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,3,48,794,8,48,1,49,1,49,1,
  	49,1,49,5,49,800,8,49,10,49,12,49,803,9,49,1,49,1,49,1,50,1,50,1,50,1,
  	50,1,50,1,50,3,50,813,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,3,50,824,8,50,1,50,3,50,827,8,50,1,51,1,51,1,52,1,52,1,52,1,52,1,52,
  	1,52,5,52,837,8,52,10,52,12,52,840,9,52,1,53,1,53,1,53,5,53,845,8,53,
  	10,53,12,53,848,9,53,1,54,1,54,1,54,1,54,1,54,1,54,5,54,856,8,54,10,54,
  	12,54,859,9,54,1,54,3,54,862,8,54,1,54,1,54,3,54,866,8,54,1,55,1,55,1,
  	55,1,55,1,55,1,55,5,55,874,8,55,10,55,12,55,877,9,55,1,55,3,55,880,8,
  	55,1,55,1,55,3,55,884,8,55,1,56,1,56,1,56,1,56,1,57,1,57,1,58,1,58,1,
  	58,1,58,1,58,1,58,1,58,1,58,3,58,900,8,58,1,58,1,58,1,58,1,58,1,58,1,
  	58,1,58,1,58,3,58,910,8,58,1,58,0,2,84,94,59,0,2,4,6,8,10,12,14,16,18,
  	20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
  	66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
  	110,112,114,116,0,11,2,0,1,3,75,75,1,0,11,12,2,0,4,8,74,74,2,0,4,4,7,
  	7,3,0,43,43,56,56,62,63,1,0,44,46,1,0,42,43,1,0,50,53,1,0,48,49,1,0,62,
  	63,2,0,1,1,75,75,1007,0,121,1,0,0,0,2,138,1,0,0,0,4,172,1,0,0,0,6,174,
  	1,0,0,0,8,188,1,0,0,0,10,190,1,0,0,0,12,206,1,0,0,0,14,218,1,0,0,0,16,
  	233,1,0,0,0,18,236,1,0,0,0,20,243,1,0,0,0,22,245,1,0,0,0,24,266,1,0,0,
  	0,26,296,1,0,0,0,28,298,1,0,0,0,30,306,1,0,0,0,32,311,1,0,0,0,34,320,
  	1,0,0,0,36,354,1,0,0,0,38,356,1,0,0,0,40,362,1,0,0,0,42,374,1,0,0,0,44,
  	385,1,0,0,0,46,388,1,0,0,0,48,391,1,0,0,0,50,397,1,0,0,0,52,400,1,0,0,
  	0,54,439,1,0,0,0,56,483,1,0,0,0,58,485,1,0,0,0,60,496,1,0,0,0,62,535,
  	1,0,0,0,64,537,1,0,0,0,66,545,1,0,0,0,68,553,1,0,0,0,70,569,1,0,0,0,72,
  	580,1,0,0,0,74,591,1,0,0,0,76,593,1,0,0,0,78,603,1,0,0,0,80,610,1,0,0,
  	0,82,614,1,0,0,0,84,616,1,0,0,0,86,629,1,0,0,0,88,636,1,0,0,0,90,638,
  	1,0,0,0,92,648,1,0,0,0,94,700,1,0,0,0,96,793,1,0,0,0,98,795,1,0,0,0,100,
  	826,1,0,0,0,102,828,1,0,0,0,104,830,1,0,0,0,106,841,1,0,0,0,108,865,1,
  	0,0,0,110,883,1,0,0,0,112,885,1,0,0,0,114,889,1,0,0,0,116,909,1,0,0,0,
  	118,120,3,2,1,0,119,118,1,0,0,0,120,123,1,0,0,0,121,119,1,0,0,0,121,122,
  	1,0,0,0,122,127,1,0,0,0,123,121,1,0,0,0,124,126,3,4,2,0,125,124,1,0,0,
  	0,126,129,1,0,0,0,127,125,1,0,0,0,127,128,1,0,0,0,128,133,1,0,0,0,129,
  	127,1,0,0,0,130,132,3,8,4,0,131,130,1,0,0,0,132,135,1,0,0,0,133,131,1,
  	0,0,0,133,134,1,0,0,0,134,136,1,0,0,0,135,133,1,0,0,0,136,137,5,0,0,1,
  	137,1,1,0,0,0,138,139,5,24,0,0,139,140,3,6,3,0,140,144,5,66,0,0,141,143,
  	3,8,4,0,142,141,1,0,0,0,143,146,1,0,0,0,144,142,1,0,0,0,144,145,1,0,0,
  	0,145,147,1,0,0,0,146,144,1,0,0,0,147,148,5,67,0,0,148,3,1,0,0,0,149,
  	150,5,23,0,0,150,151,3,6,3,0,151,152,5,70,0,0,152,173,1,0,0,0,153,154,
  	5,23,0,0,154,155,3,6,3,0,155,156,5,28,0,0,156,157,5,74,0,0,157,158,5,
  	70,0,0,158,173,1,0,0,0,159,160,5,33,0,0,160,161,3,6,3,0,161,162,5,23,
  	0,0,162,167,5,74,0,0,163,164,5,71,0,0,164,166,5,74,0,0,165,163,1,0,0,
  	0,166,169,1,0,0,0,167,165,1,0,0,0,167,168,1,0,0,0,168,170,1,0,0,0,169,
  	167,1,0,0,0,170,171,5,70,0,0,171,173,1,0,0,0,172,149,1,0,0,0,172,153,
  	1,0,0,0,172,159,1,0,0,0,173,5,1,0,0,0,174,179,5,74,0,0,175,176,5,73,0,
  	0,176,178,5,74,0,0,177,175,1,0,0,0,178,181,1,0,0,0,179,177,1,0,0,0,179,
  	180,1,0,0,0,180,7,1,0,0,0,181,179,1,0,0,0,182,189,3,12,6,0,183,189,3,
  	52,26,0,184,189,3,54,27,0,185,189,3,10,5,0,186,189,3,26,13,0,187,189,
  	3,40,20,0,188,182,1,0,0,0,188,183,1,0,0,0,188,184,1,0,0,0,188,185,1,0,
  	0,0,188,186,1,0,0,0,188,187,1,0,0,0,189,9,1,0,0,0,190,191,5,38,0,0,191,
  	194,5,74,0,0,192,193,5,15,0,0,193,195,5,74,0,0,194,192,1,0,0,0,194,195,
  	1,0,0,0,195,196,1,0,0,0,196,201,5,66,0,0,197,200,3,66,33,0,198,200,3,
  	116,58,0,199,197,1,0,0,0,199,198,1,0,0,0,200,203,1,0,0,0,201,199,1,0,
  	0,0,201,202,1,0,0,0,202,204,1,0,0,0,203,201,1,0,0,0,204,205,5,67,0,0,
  	205,11,1,0,0,0,206,207,3,78,39,0,207,209,5,74,0,0,208,210,3,58,29,0,209,
  	208,1,0,0,0,209,210,1,0,0,0,210,211,1,0,0,0,211,213,5,64,0,0,212,214,
  	3,14,7,0,213,212,1,0,0,0,213,214,1,0,0,0,214,215,1,0,0,0,215,216,5,65,
  	0,0,216,217,3,22,11,0,217,13,1,0,0,0,218,223,3,16,8,0,219,220,5,71,0,
  	0,220,222,3,16,8,0,221,219,1,0,0,0,222,225,1,0,0,0,223,221,1,0,0,0,223,
  	224,1,0,0,0,224,230,1,0,0,0,225,223,1,0,0,0,226,227,5,71,0,0,227,229,
  	3,18,9,0,228,226,1,0,0,0,229,232,1,0,0,0,230,228,1,0,0,0,230,231,1,0,
  	0,0,231,15,1,0,0,0,232,230,1,0,0,0,233,234,3,70,35,0,234,235,5,74,0,0,
  	235,17,1,0,0,0,236,237,3,70,35,0,237,238,5,74,0,0,238,241,5,47,0,0,239,
  	242,3,20,10,0,240,242,5,35,0,0,241,239,1,0,0,0,241,240,1,0,0,0,242,19,
  	1,0,0,0,243,244,7,0,0,0,244,21,1,0,0,0,245,249,5,66,0,0,246,248,3,24,
  	12,0,247,246,1,0,0,0,248,251,1,0,0,0,249,247,1,0,0,0,249,250,1,0,0,0,
  	250,252,1,0,0,0,251,249,1,0,0,0,252,253,5,67,0,0,253,23,1,0,0,0,254,267,
  	3,22,11,0,255,267,3,26,13,0,256,267,3,30,15,0,257,267,3,50,25,0,258,267,
  	3,32,16,0,259,267,3,34,17,0,260,267,3,36,18,0,261,267,3,38,19,0,262,267,
  	3,40,20,0,263,267,3,44,22,0,264,267,3,46,23,0,265,267,3,48,24,0,266,254,
  	1,0,0,0,266,255,1,0,0,0,266,256,1,0,0,0,266,257,1,0,0,0,266,258,1,0,0,
  	0,266,259,1,0,0,0,266,260,1,0,0,0,266,261,1,0,0,0,266,262,1,0,0,0,266,
  	263,1,0,0,0,266,264,1,0,0,0,266,265,1,0,0,0,267,25,1,0,0,0,268,269,5,
  	11,0,0,269,270,3,70,35,0,270,271,3,28,14,0,271,272,5,47,0,0,272,273,3,
  	94,47,0,273,274,5,70,0,0,274,297,1,0,0,0,275,276,5,12,0,0,276,277,3,70,
  	35,0,277,278,3,28,14,0,278,279,5,47,0,0,279,280,3,94,47,0,280,281,5,70,
  	0,0,281,297,1,0,0,0,282,283,5,10,0,0,283,284,3,28,14,0,284,285,5,47,0,
  	0,285,286,3,94,47,0,286,287,5,70,0,0,287,297,1,0,0,0,288,289,3,70,35,
  	0,289,292,3,28,14,0,290,291,5,47,0,0,291,293,3,94,47,0,292,290,1,0,0,
  	0,292,293,1,0,0,0,293,294,1,0,0,0,294,295,5,70,0,0,295,297,1,0,0,0,296,
  	268,1,0,0,0,296,275,1,0,0,0,296,282,1,0,0,0,296,288,1,0,0,0,297,27,1,
  	0,0,0,298,303,5,74,0,0,299,300,5,71,0,0,300,302,5,74,0,0,301,299,1,0,
  	0,0,302,305,1,0,0,0,303,301,1,0,0,0,303,304,1,0,0,0,304,29,1,0,0,0,305,
  	303,1,0,0,0,306,307,3,94,47,0,307,308,5,47,0,0,308,309,3,94,47,0,309,
  	310,5,70,0,0,310,31,1,0,0,0,311,312,5,18,0,0,312,313,5,64,0,0,313,314,
  	3,94,47,0,314,315,5,65,0,0,315,318,3,24,12,0,316,317,5,19,0,0,317,319,
  	3,24,12,0,318,316,1,0,0,0,318,319,1,0,0,0,319,33,1,0,0,0,320,321,5,20,
  	0,0,321,322,5,64,0,0,322,323,3,94,47,0,323,324,5,65,0,0,324,325,3,24,
  	12,0,325,35,1,0,0,0,326,327,5,21,0,0,327,330,5,64,0,0,328,331,5,10,0,
  	0,329,331,3,70,35,0,330,328,1,0,0,0,330,329,1,0,0,0,331,332,1,0,0,0,332,
  	333,5,74,0,0,333,334,5,22,0,0,334,335,3,94,47,0,335,336,5,65,0,0,336,
  	337,3,24,12,0,337,355,1,0,0,0,338,339,5,21,0,0,339,343,5,64,0,0,340,344,
  	3,26,13,0,341,344,3,50,25,0,342,344,5,70,0,0,343,340,1,0,0,0,343,341,
  	1,0,0,0,343,342,1,0,0,0,344,346,1,0,0,0,345,347,3,94,47,0,346,345,1,0,
  	0,0,346,347,1,0,0,0,347,348,1,0,0,0,348,350,5,70,0,0,349,351,3,94,47,
  	0,350,349,1,0,0,0,350,351,1,0,0,0,351,352,1,0,0,0,352,353,5,65,0,0,353,
  	355,3,24,12,0,354,326,1,0,0,0,354,338,1,0,0,0,355,37,1,0,0,0,356,358,
  	5,17,0,0,357,359,3,94,47,0,358,357,1,0,0,0,358,359,1,0,0,0,359,360,1,
  	0,0,0,360,361,5,70,0,0,361,39,1,0,0,0,362,363,5,25,0,0,363,367,3,22,11,
  	0,364,366,3,42,21,0,365,364,1,0,0,0,366,369,1,0,0,0,367,365,1,0,0,0,367,
  	368,1,0,0,0,368,372,1,0,0,0,369,367,1,0,0,0,370,371,5,27,0,0,371,373,
  	3,22,11,0,372,370,1,0,0,0,372,373,1,0,0,0,373,41,1,0,0,0,374,375,5,26,
  	0,0,375,376,5,64,0,0,376,377,3,70,35,0,377,380,5,74,0,0,378,379,5,39,
  	0,0,379,381,3,94,47,0,380,378,1,0,0,0,380,381,1,0,0,0,381,382,1,0,0,0,
  	382,383,5,65,0,0,383,384,3,22,11,0,384,43,1,0,0,0,385,386,5,29,0,0,386,
  	387,5,70,0,0,387,45,1,0,0,0,388,389,5,30,0,0,389,390,5,70,0,0,390,47,
  	1,0,0,0,391,392,5,40,0,0,392,393,5,64,0,0,393,394,3,94,47,0,394,395,5,
  	65,0,0,395,396,5,70,0,0,396,49,1,0,0,0,397,398,3,94,47,0,398,399,5,70,
  	0,0,399,51,1,0,0,0,400,401,5,13,0,0,401,403,5,74,0,0,402,404,3,58,29,
  	0,403,402,1,0,0,0,403,404,1,0,0,0,404,410,1,0,0,0,405,406,5,15,0,0,406,
  	408,5,74,0,0,407,409,3,60,30,0,408,407,1,0,0,0,408,409,1,0,0,0,409,411,
  	1,0,0,0,410,405,1,0,0,0,410,411,1,0,0,0,411,427,1,0,0,0,412,413,5,16,
  	0,0,413,415,5,74,0,0,414,416,3,60,30,0,415,414,1,0,0,0,415,416,1,0,0,
  	0,416,424,1,0,0,0,417,418,5,71,0,0,418,420,5,74,0,0,419,421,3,60,30,0,
  	420,419,1,0,0,0,420,421,1,0,0,0,421,423,1,0,0,0,422,417,1,0,0,0,423,426,
  	1,0,0,0,424,422,1,0,0,0,424,425,1,0,0,0,425,428,1,0,0,0,426,424,1,0,0,
  	0,427,412,1,0,0,0,427,428,1,0,0,0,428,429,1,0,0,0,429,434,5,66,0,0,430,
  	433,3,66,33,0,431,433,3,62,31,0,432,430,1,0,0,0,432,431,1,0,0,0,433,436,
  	1,0,0,0,434,432,1,0,0,0,434,435,1,0,0,0,435,437,1,0,0,0,436,434,1,0,0,
  	0,437,438,5,67,0,0,438,53,1,0,0,0,439,440,5,14,0,0,440,442,5,74,0,0,441,
  	443,3,58,29,0,442,441,1,0,0,0,442,443,1,0,0,0,443,459,1,0,0,0,444,445,
  	5,15,0,0,445,447,5,74,0,0,446,448,3,60,30,0,447,446,1,0,0,0,447,448,1,
  	0,0,0,448,456,1,0,0,0,449,450,5,71,0,0,450,452,5,74,0,0,451,453,3,60,
  	30,0,452,451,1,0,0,0,452,453,1,0,0,0,453,455,1,0,0,0,454,449,1,0,0,0,
  	455,458,1,0,0,0,456,454,1,0,0,0,456,457,1,0,0,0,457,460,1,0,0,0,458,456,
  	1,0,0,0,459,444,1,0,0,0,459,460,1,0,0,0,460,461,1,0,0,0,461,465,5,66,
  	0,0,462,464,3,56,28,0,463,462,1,0,0,0,464,467,1,0,0,0,465,463,1,0,0,0,
  	465,466,1,0,0,0,466,468,1,0,0,0,467,465,1,0,0,0,468,469,5,67,0,0,469,
  	55,1,0,0,0,470,471,3,78,39,0,471,472,5,74,0,0,472,474,5,64,0,0,473,475,
  	3,14,7,0,474,473,1,0,0,0,474,475,1,0,0,0,475,476,1,0,0,0,476,477,5,65,
  	0,0,477,478,5,70,0,0,478,484,1,0,0,0,479,480,3,78,39,0,480,481,5,74,0,
  	0,481,482,5,70,0,0,482,484,1,0,0,0,483,470,1,0,0,0,483,479,1,0,0,0,484,
  	57,1,0,0,0,485,486,5,50,0,0,486,491,5,74,0,0,487,488,5,71,0,0,488,490,
  	5,74,0,0,489,487,1,0,0,0,490,493,1,0,0,0,491,489,1,0,0,0,491,492,1,0,
  	0,0,492,494,1,0,0,0,493,491,1,0,0,0,494,495,5,51,0,0,495,59,1,0,0,0,496,
  	497,5,50,0,0,497,502,3,70,35,0,498,499,5,71,0,0,499,501,3,70,35,0,500,
  	498,1,0,0,0,501,504,1,0,0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,505,1,
  	0,0,0,504,502,1,0,0,0,505,506,5,51,0,0,506,61,1,0,0,0,507,509,7,1,0,0,
  	508,507,1,0,0,0,508,509,1,0,0,0,509,510,1,0,0,0,510,511,3,70,35,0,511,
  	512,5,74,0,0,512,513,5,70,0,0,513,536,1,0,0,0,514,515,3,78,39,0,515,517,
  	5,74,0,0,516,518,3,58,29,0,517,516,1,0,0,0,517,518,1,0,0,0,518,519,1,
  	0,0,0,519,521,5,64,0,0,520,522,3,14,7,0,521,520,1,0,0,0,521,522,1,0,0,
  	0,522,523,1,0,0,0,523,524,5,65,0,0,524,525,3,22,11,0,525,536,1,0,0,0,
  	526,527,3,78,39,0,527,528,5,74,0,0,528,530,5,64,0,0,529,531,3,64,32,0,
  	530,529,1,0,0,0,530,531,1,0,0,0,531,532,1,0,0,0,532,533,5,65,0,0,533,
  	534,3,22,11,0,534,536,1,0,0,0,535,508,1,0,0,0,535,514,1,0,0,0,535,526,
  	1,0,0,0,536,63,1,0,0,0,537,542,3,16,8,0,538,539,5,71,0,0,539,541,3,16,
  	8,0,540,538,1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,0,542,543,1,0,0,0,543,
  	65,1,0,0,0,544,542,1,0,0,0,545,546,5,74,0,0,546,548,5,64,0,0,547,549,
  	3,14,7,0,548,547,1,0,0,0,548,549,1,0,0,0,549,550,1,0,0,0,550,551,5,65,
  	0,0,551,552,3,68,34,0,552,67,1,0,0,0,553,564,5,66,0,0,554,555,5,34,0,
  	0,555,556,5,72,0,0,556,557,5,74,0,0,557,558,5,47,0,0,558,559,3,94,47,
  	0,559,560,5,70,0,0,560,563,1,0,0,0,561,563,3,24,12,0,562,554,1,0,0,0,
  	562,561,1,0,0,0,563,566,1,0,0,0,564,562,1,0,0,0,564,565,1,0,0,0,565,567,
  	1,0,0,0,566,564,1,0,0,0,567,568,5,67,0,0,568,69,1,0,0,0,569,573,3,74,
  	37,0,570,572,3,72,36,0,571,570,1,0,0,0,572,575,1,0,0,0,573,571,1,0,0,
  	0,573,574,1,0,0,0,574,71,1,0,0,0,575,573,1,0,0,0,576,577,5,57,0,0,577,
  	581,3,74,37,0,578,579,5,58,0,0,579,581,3,74,37,0,580,576,1,0,0,0,580,
  	578,1,0,0,0,581,73,1,0,0,0,582,592,3,80,40,0,583,585,3,76,38,0,584,586,
  	3,60,30,0,585,584,1,0,0,0,585,586,1,0,0,0,586,592,1,0,0,0,587,592,3,90,
  	45,0,588,592,3,84,42,0,589,592,3,86,43,0,590,592,3,82,41,0,591,582,1,
  	0,0,0,591,583,1,0,0,0,591,587,1,0,0,0,591,588,1,0,0,0,591,589,1,0,0,0,
  	591,590,1,0,0,0,592,75,1,0,0,0,593,598,5,74,0,0,594,595,5,73,0,0,595,
  	597,5,74,0,0,596,594,1,0,0,0,597,600,1,0,0,0,598,596,1,0,0,0,598,599,
  	1,0,0,0,599,77,1,0,0,0,600,598,1,0,0,0,601,604,3,70,35,0,602,604,5,8,
  	0,0,603,601,1,0,0,0,603,602,1,0,0,0,604,79,1,0,0,0,605,611,3,76,38,0,
  	606,611,3,90,45,0,607,611,3,84,42,0,608,611,3,86,43,0,609,611,3,82,41,
  	0,610,605,1,0,0,0,610,606,1,0,0,0,610,607,1,0,0,0,610,608,1,0,0,0,610,
  	609,1,0,0,0,611,612,1,0,0,0,612,613,5,59,0,0,613,81,1,0,0,0,614,615,7,
  	2,0,0,615,83,1,0,0,0,616,617,6,42,-1,0,617,618,3,82,41,0,618,619,5,68,
  	0,0,619,620,5,69,0,0,620,626,1,0,0,0,621,622,10,1,0,0,622,623,5,68,0,
  	0,623,625,5,69,0,0,624,621,1,0,0,0,625,628,1,0,0,0,626,624,1,0,0,0,626,
  	627,1,0,0,0,627,85,1,0,0,0,628,626,1,0,0,0,629,630,5,32,0,0,630,631,5,
  	50,0,0,631,632,3,88,44,0,632,633,5,71,0,0,633,634,3,70,35,0,634,635,5,
  	51,0,0,635,87,1,0,0,0,636,637,7,3,0,0,637,89,1,0,0,0,638,639,5,9,0,0,
  	639,640,5,50,0,0,640,641,3,78,39,0,641,642,5,51,0,0,642,644,5,64,0,0,
  	643,645,3,92,46,0,644,643,1,0,0,0,644,645,1,0,0,0,645,646,1,0,0,0,646,
  	647,5,65,0,0,647,91,1,0,0,0,648,653,3,70,35,0,649,650,5,71,0,0,650,652,
  	3,70,35,0,651,649,1,0,0,0,652,655,1,0,0,0,653,651,1,0,0,0,653,654,1,0,
  	0,0,654,93,1,0,0,0,655,653,1,0,0,0,656,657,6,47,-1,0,657,701,3,96,48,
  	0,658,659,5,31,0,0,659,661,3,76,38,0,660,662,3,60,30,0,661,660,1,0,0,
  	0,661,662,1,0,0,0,662,663,1,0,0,0,663,665,5,64,0,0,664,666,3,106,53,0,
  	665,664,1,0,0,0,665,666,1,0,0,0,666,667,1,0,0,0,667,668,5,65,0,0,668,
  	701,1,0,0,0,669,670,5,74,0,0,670,672,5,64,0,0,671,673,3,106,53,0,672,
  	671,1,0,0,0,672,673,1,0,0,0,673,674,1,0,0,0,674,701,5,65,0,0,675,676,
  	5,37,0,0,676,701,3,94,47,21,677,678,5,64,0,0,678,679,3,70,35,0,679,680,
  	5,65,0,0,680,681,3,94,47,15,681,701,1,0,0,0,682,683,5,64,0,0,683,684,
  	3,94,47,0,684,685,5,65,0,0,685,701,1,0,0,0,686,687,7,4,0,0,687,701,3,
  	94,47,12,688,690,5,64,0,0,689,691,3,104,52,0,690,689,1,0,0,0,690,691,
  	1,0,0,0,691,692,1,0,0,0,692,693,5,65,0,0,693,698,5,61,0,0,694,695,3,78,
  	39,0,695,696,3,22,11,0,696,699,1,0,0,0,697,699,3,94,47,0,698,694,1,0,
  	0,0,698,697,1,0,0,0,699,701,1,0,0,0,700,656,1,0,0,0,700,658,1,0,0,0,700,
  	669,1,0,0,0,700,675,1,0,0,0,700,677,1,0,0,0,700,682,1,0,0,0,700,686,1,
  	0,0,0,700,688,1,0,0,0,701,780,1,0,0,0,702,703,10,10,0,0,703,704,7,5,0,
  	0,704,779,3,94,47,11,705,706,10,9,0,0,706,707,7,6,0,0,707,779,3,94,47,
  	10,708,709,10,8,0,0,709,710,7,7,0,0,710,779,3,94,47,9,711,712,10,7,0,
  	0,712,713,7,8,0,0,713,779,3,94,47,8,714,715,10,6,0,0,715,716,5,41,0,0,
  	716,779,3,94,47,7,717,718,10,5,0,0,718,719,5,54,0,0,719,779,3,94,47,6,
  	720,721,10,4,0,0,721,722,5,55,0,0,722,779,3,94,47,5,723,724,10,3,0,0,
  	724,725,5,59,0,0,725,726,3,94,47,0,726,727,5,60,0,0,727,728,3,94,47,3,
  	728,779,1,0,0,0,729,730,10,2,0,0,730,731,5,47,0,0,731,779,3,94,47,2,732,
  	733,10,22,0,0,733,734,5,36,0,0,734,779,3,70,35,0,735,736,10,20,0,0,736,
  	737,5,72,0,0,737,779,5,74,0,0,738,739,10,19,0,0,739,740,5,59,0,0,740,
  	741,5,72,0,0,741,779,5,74,0,0,742,743,10,18,0,0,743,744,5,72,0,0,744,
  	746,5,74,0,0,745,747,3,60,30,0,746,745,1,0,0,0,746,747,1,0,0,0,747,748,
  	1,0,0,0,748,750,5,64,0,0,749,751,3,106,53,0,750,749,1,0,0,0,750,751,1,
  	0,0,0,751,752,1,0,0,0,752,779,5,65,0,0,753,754,10,17,0,0,754,755,5,59,
  	0,0,755,756,5,72,0,0,756,758,5,74,0,0,757,759,3,60,30,0,758,757,1,0,0,
  	0,758,759,1,0,0,0,759,760,1,0,0,0,760,762,5,64,0,0,761,763,3,106,53,0,
  	762,761,1,0,0,0,762,763,1,0,0,0,763,764,1,0,0,0,764,779,5,65,0,0,765,
  	770,10,16,0,0,766,767,5,68,0,0,767,768,3,94,47,0,768,769,5,69,0,0,769,
  	771,1,0,0,0,770,766,1,0,0,0,771,772,1,0,0,0,772,770,1,0,0,0,772,773,1,
  	0,0,0,773,779,1,0,0,0,774,775,10,14,0,0,775,779,5,56,0,0,776,777,10,11,
  	0,0,777,779,7,9,0,0,778,702,1,0,0,0,778,705,1,0,0,0,778,708,1,0,0,0,778,
  	711,1,0,0,0,778,714,1,0,0,0,778,717,1,0,0,0,778,720,1,0,0,0,778,723,1,
  	0,0,0,778,729,1,0,0,0,778,732,1,0,0,0,778,735,1,0,0,0,778,738,1,0,0,0,
  	778,742,1,0,0,0,778,753,1,0,0,0,778,765,1,0,0,0,778,774,1,0,0,0,778,776,
  	1,0,0,0,779,782,1,0,0,0,780,778,1,0,0,0,780,781,1,0,0,0,781,95,1,0,0,
  	0,782,780,1,0,0,0,783,794,5,34,0,0,784,794,5,74,0,0,785,794,5,1,0,0,786,
  	794,5,2,0,0,787,794,5,75,0,0,788,794,3,98,49,0,789,794,5,3,0,0,790,794,
  	5,35,0,0,791,794,3,108,54,0,792,794,3,110,55,0,793,783,1,0,0,0,793,784,
  	1,0,0,0,793,785,1,0,0,0,793,786,1,0,0,0,793,787,1,0,0,0,793,788,1,0,0,
  	0,793,789,1,0,0,0,793,790,1,0,0,0,793,791,1,0,0,0,793,792,1,0,0,0,794,
  	97,1,0,0,0,795,796,5,76,0,0,796,801,3,94,47,0,797,798,5,77,0,0,798,800,
  	3,94,47,0,799,797,1,0,0,0,800,803,1,0,0,0,801,799,1,0,0,0,801,802,1,0,
  	0,0,802,804,1,0,0,0,803,801,1,0,0,0,804,805,5,78,0,0,805,99,1,0,0,0,806,
  	807,5,72,0,0,807,827,5,74,0,0,808,809,5,72,0,0,809,810,5,74,0,0,810,812,
  	5,64,0,0,811,813,3,106,53,0,812,811,1,0,0,0,812,813,1,0,0,0,813,814,1,
  	0,0,0,814,827,5,65,0,0,815,816,5,59,0,0,816,817,5,72,0,0,817,827,5,74,
  	0,0,818,819,5,59,0,0,819,820,5,72,0,0,820,821,5,74,0,0,821,823,5,64,0,
  	0,822,824,3,106,53,0,823,822,1,0,0,0,823,824,1,0,0,0,824,825,1,0,0,0,
  	825,827,5,65,0,0,826,806,1,0,0,0,826,808,1,0,0,0,826,815,1,0,0,0,826,
  	818,1,0,0,0,827,101,1,0,0,0,828,829,5,75,0,0,829,103,1,0,0,0,830,831,
  	3,70,35,0,831,838,5,74,0,0,832,833,5,71,0,0,833,834,3,70,35,0,834,835,
  	5,74,0,0,835,837,1,0,0,0,836,832,1,0,0,0,837,840,1,0,0,0,838,836,1,0,
  	0,0,838,839,1,0,0,0,839,105,1,0,0,0,840,838,1,0,0,0,841,846,3,94,47,0,
  	842,843,5,71,0,0,843,845,3,94,47,0,844,842,1,0,0,0,845,848,1,0,0,0,846,
  	844,1,0,0,0,846,847,1,0,0,0,847,107,1,0,0,0,848,846,1,0,0,0,849,850,5,
  	68,0,0,850,866,5,69,0,0,851,852,5,68,0,0,852,857,3,94,47,0,853,854,5,
  	71,0,0,854,856,3,94,47,0,855,853,1,0,0,0,856,859,1,0,0,0,857,855,1,0,
  	0,0,857,858,1,0,0,0,858,861,1,0,0,0,859,857,1,0,0,0,860,862,5,71,0,0,
  	861,860,1,0,0,0,861,862,1,0,0,0,862,863,1,0,0,0,863,864,5,69,0,0,864,
  	866,1,0,0,0,865,849,1,0,0,0,865,851,1,0,0,0,866,109,1,0,0,0,867,868,5,
  	66,0,0,868,884,5,67,0,0,869,870,5,66,0,0,870,875,3,112,56,0,871,872,5,
  	71,0,0,872,874,3,112,56,0,873,871,1,0,0,0,874,877,1,0,0,0,875,873,1,0,
  	0,0,875,876,1,0,0,0,876,879,1,0,0,0,877,875,1,0,0,0,878,880,5,71,0,0,
  	879,878,1,0,0,0,879,880,1,0,0,0,880,881,1,0,0,0,881,882,5,67,0,0,882,
  	884,1,0,0,0,883,867,1,0,0,0,883,869,1,0,0,0,884,111,1,0,0,0,885,886,7,
  	10,0,0,886,887,5,60,0,0,887,888,3,94,47,0,888,113,1,0,0,0,889,890,7,10,
  	0,0,890,115,1,0,0,0,891,892,3,70,35,0,892,893,5,74,0,0,893,894,5,70,0,
  	0,894,910,1,0,0,0,895,896,3,78,39,0,896,897,5,74,0,0,897,899,5,64,0,0,
  	898,900,3,14,7,0,899,898,1,0,0,0,899,900,1,0,0,0,900,901,1,0,0,0,901,
  	902,5,65,0,0,902,903,3,22,11,0,903,910,1,0,0,0,904,905,5,39,0,0,905,906,
  	3,70,35,0,906,907,5,74,0,0,907,908,5,70,0,0,908,910,1,0,0,0,909,891,1,
  	0,0,0,909,895,1,0,0,0,909,904,1,0,0,0,910,117,1,0,0,0,97,121,127,133,
  	144,167,172,179,188,194,199,201,209,213,223,230,241,249,266,292,296,303,
  	318,330,343,346,350,354,358,367,372,380,403,408,410,415,420,424,427,432,
  	434,442,447,452,456,459,465,474,483,491,502,508,517,521,530,535,542,548,
  	562,564,573,580,585,591,598,603,610,626,644,653,661,665,672,690,698,700,
  	746,750,758,762,772,778,780,793,801,812,823,826,838,846,857,861,865,875,
  	879,883,899,909
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  prystparserParserStaticData = staticData.release();
}

}

PrystParser::PrystParser(TokenStream *input) : PrystParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

PrystParser::PrystParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  PrystParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *prystparserParserStaticData->atn, prystparserParserStaticData->decisionToDFA, prystparserParserStaticData->sharedContextCache, options);
}

PrystParser::~PrystParser() {
  delete _interpreter;
}

const atn::ATN& PrystParser::getATN() const {
  return *prystparserParserStaticData->atn;
}

std::string PrystParser::getGrammarFileName() const {
  return "PrystParser.g4";
}

const std::vector<std::string>& PrystParser::getRuleNames() const {
  return prystparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& PrystParser::getVocabulary() const {
  return prystparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView PrystParser::getSerializedATN() const {
  return prystparserParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

PrystParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ProgramContext::EOF() {
  return getToken(PrystParser::EOF, 0);
}

std::vector<PrystParser::ModuleDeclContext *> PrystParser::ProgramContext::moduleDecl() {
  return getRuleContexts<PrystParser::ModuleDeclContext>();
}

PrystParser::ModuleDeclContext* PrystParser::ProgramContext::moduleDecl(size_t i) {
  return getRuleContext<PrystParser::ModuleDeclContext>(i);
}

std::vector<PrystParser::ImportDeclContext *> PrystParser::ProgramContext::importDecl() {
  return getRuleContexts<PrystParser::ImportDeclContext>();
}

PrystParser::ImportDeclContext* PrystParser::ProgramContext::importDecl(size_t i) {
  return getRuleContext<PrystParser::ImportDeclContext>(i);
}

std::vector<PrystParser::DeclarationContext *> PrystParser::ProgramContext::declaration() {
  return getRuleContexts<PrystParser::DeclarationContext>();
}

PrystParser::DeclarationContext* PrystParser::ProgramContext::declaration(size_t i) {
  return getRuleContext<PrystParser::DeclarationContext>(i);
}


size_t PrystParser::ProgramContext::getRuleIndex() const {
  return PrystParser::RuleProgram;
}


std::any PrystParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ProgramContext* PrystParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, PrystParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(121);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::MODULE) {
      setState(118);
      moduleDecl();
      setState(123);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(127);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::IMPORT

    || _la == PrystParser::FROM) {
      setState(124);
      importDecl();
      setState(129);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(133);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 279206461424) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(130);
      declaration();
      setState(135);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(136);
    match(PrystParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleDeclContext ------------------------------------------------------------------

PrystParser::ModuleDeclContext::ModuleDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ModuleDeclContext::MODULE() {
  return getToken(PrystParser::MODULE, 0);
}

PrystParser::ImportPathContext* PrystParser::ModuleDeclContext::importPath() {
  return getRuleContext<PrystParser::ImportPathContext>(0);
}

tree::TerminalNode* PrystParser::ModuleDeclContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::ModuleDeclContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

std::vector<PrystParser::DeclarationContext *> PrystParser::ModuleDeclContext::declaration() {
  return getRuleContexts<PrystParser::DeclarationContext>();
}

PrystParser::DeclarationContext* PrystParser::ModuleDeclContext::declaration(size_t i) {
  return getRuleContext<PrystParser::DeclarationContext>(i);
}


size_t PrystParser::ModuleDeclContext::getRuleIndex() const {
  return PrystParser::RuleModuleDecl;
}


std::any PrystParser::ModuleDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitModuleDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ModuleDeclContext* PrystParser::moduleDecl() {
  ModuleDeclContext *_localctx = _tracker.createInstance<ModuleDeclContext>(_ctx, getState());
  enterRule(_localctx, 2, PrystParser::RuleModuleDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(138);
    match(PrystParser::MODULE);
    setState(139);
    importPath();
    setState(140);
    match(PrystParser::LBRACE);
    setState(144);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 279206461424) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(141);
      declaration();
      setState(146);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(147);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclContext ------------------------------------------------------------------

PrystParser::ImportDeclContext::ImportDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ImportDeclContext::IMPORT() {
  return getToken(PrystParser::IMPORT, 0);
}

PrystParser::ImportPathContext* PrystParser::ImportDeclContext::importPath() {
  return getRuleContext<PrystParser::ImportPathContext>(0);
}

tree::TerminalNode* PrystParser::ImportDeclContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

tree::TerminalNode* PrystParser::ImportDeclContext::AS() {
  return getToken(PrystParser::AS, 0);
}

std::vector<tree::TerminalNode *> PrystParser::ImportDeclContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::ImportDeclContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

tree::TerminalNode* PrystParser::ImportDeclContext::FROM() {
  return getToken(PrystParser::FROM, 0);
}

std::vector<tree::TerminalNode *> PrystParser::ImportDeclContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::ImportDeclContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::ImportDeclContext::getRuleIndex() const {
  return PrystParser::RuleImportDecl;
}


std::any PrystParser::ImportDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitImportDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ImportDeclContext* PrystParser::importDecl() {
  ImportDeclContext *_localctx = _tracker.createInstance<ImportDeclContext>(_ctx, getState());
  enterRule(_localctx, 4, PrystParser::RuleImportDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(172);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(149);
      match(PrystParser::IMPORT);
      setState(150);
      importPath();
      setState(151);
      match(PrystParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(153);
      match(PrystParser::IMPORT);
      setState(154);
      importPath();
      setState(155);
      match(PrystParser::AS);
      setState(156);
      match(PrystParser::IDENTIFIER);
      setState(157);
      match(PrystParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(159);
      match(PrystParser::FROM);
      setState(160);
      importPath();
      setState(161);
      match(PrystParser::IMPORT);
      setState(162);
      match(PrystParser::IDENTIFIER);
      setState(167);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PrystParser::COMMA) {
        setState(163);
        match(PrystParser::COMMA);
        setState(164);
        match(PrystParser::IDENTIFIER);
        setState(169);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(170);
      match(PrystParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportPathContext ------------------------------------------------------------------

PrystParser::ImportPathContext::ImportPathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PrystParser::ImportPathContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::ImportPathContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> PrystParser::ImportPathContext::DOUBLE_COLON() {
  return getTokens(PrystParser::DOUBLE_COLON);
}

tree::TerminalNode* PrystParser::ImportPathContext::DOUBLE_COLON(size_t i) {
  return getToken(PrystParser::DOUBLE_COLON, i);
}


size_t PrystParser::ImportPathContext::getRuleIndex() const {
  return PrystParser::RuleImportPath;
}


std::any PrystParser::ImportPathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitImportPath(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ImportPathContext* PrystParser::importPath() {
  ImportPathContext *_localctx = _tracker.createInstance<ImportPathContext>(_ctx, getState());
  enterRule(_localctx, 6, PrystParser::RuleImportPath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(174);
    match(PrystParser::IDENTIFIER);
    setState(179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::DOUBLE_COLON) {
      setState(175);
      match(PrystParser::DOUBLE_COLON);
      setState(176);
      match(PrystParser::IDENTIFIER);
      setState(181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

PrystParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::FunctionDeclContext* PrystParser::DeclarationContext::functionDecl() {
  return getRuleContext<PrystParser::FunctionDeclContext>(0);
}

PrystParser::ClassDeclContext* PrystParser::DeclarationContext::classDecl() {
  return getRuleContext<PrystParser::ClassDeclContext>(0);
}

PrystParser::InterfaceDeclContext* PrystParser::DeclarationContext::interfaceDecl() {
  return getRuleContext<PrystParser::InterfaceDeclContext>(0);
}

PrystParser::ErrorDeclContext* PrystParser::DeclarationContext::errorDecl() {
  return getRuleContext<PrystParser::ErrorDeclContext>(0);
}

PrystParser::VarDeclContext* PrystParser::DeclarationContext::varDecl() {
  return getRuleContext<PrystParser::VarDeclContext>(0);
}

PrystParser::TryStmtContext* PrystParser::DeclarationContext::tryStmt() {
  return getRuleContext<PrystParser::TryStmtContext>(0);
}


size_t PrystParser::DeclarationContext::getRuleIndex() const {
  return PrystParser::RuleDeclaration;
}


std::any PrystParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::DeclarationContext* PrystParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 8, PrystParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(182);
      functionDecl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(183);
      classDecl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(184);
      interfaceDecl();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(185);
      errorDecl();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(186);
      varDecl();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(187);
      tryStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorDeclContext ------------------------------------------------------------------

PrystParser::ErrorDeclContext::ErrorDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ErrorDeclContext::ERROR() {
  return getToken(PrystParser::ERROR, 0);
}

std::vector<tree::TerminalNode *> PrystParser::ErrorDeclContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::ErrorDeclContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

tree::TerminalNode* PrystParser::ErrorDeclContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::ErrorDeclContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

tree::TerminalNode* PrystParser::ErrorDeclContext::EXTENDS() {
  return getToken(PrystParser::EXTENDS, 0);
}

std::vector<PrystParser::ConstructorDeclContext *> PrystParser::ErrorDeclContext::constructorDecl() {
  return getRuleContexts<PrystParser::ConstructorDeclContext>();
}

PrystParser::ConstructorDeclContext* PrystParser::ErrorDeclContext::constructorDecl(size_t i) {
  return getRuleContext<PrystParser::ConstructorDeclContext>(i);
}

std::vector<PrystParser::ErrorMemberContext *> PrystParser::ErrorDeclContext::errorMember() {
  return getRuleContexts<PrystParser::ErrorMemberContext>();
}

PrystParser::ErrorMemberContext* PrystParser::ErrorDeclContext::errorMember(size_t i) {
  return getRuleContext<PrystParser::ErrorMemberContext>(i);
}


size_t PrystParser::ErrorDeclContext::getRuleIndex() const {
  return PrystParser::RuleErrorDecl;
}


std::any PrystParser::ErrorDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitErrorDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ErrorDeclContext* PrystParser::errorDecl() {
  ErrorDeclContext *_localctx = _tracker.createInstance<ErrorDeclContext>(_ctx, getState());
  enterRule(_localctx, 10, PrystParser::RuleErrorDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(190);
    match(PrystParser::ERROR);
    setState(191);
    match(PrystParser::IDENTIFIER);
    setState(194);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::EXTENDS) {
      setState(192);
      match(PrystParser::EXTENDS);
      setState(193);
      match(PrystParser::IDENTIFIER);
    }
    setState(196);
    match(PrystParser::LBRACE);
    setState(201);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 554050782192) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(199);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        setState(197);
        constructorDecl();
        break;
      }

      case 2: {
        setState(198);
        errorMember();
        break;
      }

      default:
        break;
      }
      setState(203);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(204);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclContext ------------------------------------------------------------------

PrystParser::FunctionDeclContext::FunctionDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::ReturnTypeContext* PrystParser::FunctionDeclContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

tree::TerminalNode* PrystParser::FunctionDeclContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::FunctionDeclContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::FunctionDeclContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::BlockContext* PrystParser::FunctionDeclContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

PrystParser::GenericParamsContext* PrystParser::FunctionDeclContext::genericParams() {
  return getRuleContext<PrystParser::GenericParamsContext>(0);
}

PrystParser::ParametersContext* PrystParser::FunctionDeclContext::parameters() {
  return getRuleContext<PrystParser::ParametersContext>(0);
}


size_t PrystParser::FunctionDeclContext::getRuleIndex() const {
  return PrystParser::RuleFunctionDecl;
}


std::any PrystParser::FunctionDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitFunctionDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::FunctionDeclContext* PrystParser::functionDecl() {
  FunctionDeclContext *_localctx = _tracker.createInstance<FunctionDeclContext>(_ctx, getState());
  enterRule(_localctx, 12, PrystParser::RuleFunctionDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(206);
    returnType();
    setState(207);
    match(PrystParser::IDENTIFIER);
    setState(209);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::LT) {
      setState(208);
      genericParams();
    }
    setState(211);
    match(PrystParser::LPAREN);
    setState(213);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(212);
      parameters();
    }
    setState(215);
    match(PrystParser::RPAREN);
    setState(216);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

PrystParser::ParametersContext::ParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::ParameterContext *> PrystParser::ParametersContext::parameter() {
  return getRuleContexts<PrystParser::ParameterContext>();
}

PrystParser::ParameterContext* PrystParser::ParametersContext::parameter(size_t i) {
  return getRuleContext<PrystParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::ParametersContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::ParametersContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}

std::vector<PrystParser::DefaultParamContext *> PrystParser::ParametersContext::defaultParam() {
  return getRuleContexts<PrystParser::DefaultParamContext>();
}

PrystParser::DefaultParamContext* PrystParser::ParametersContext::defaultParam(size_t i) {
  return getRuleContext<PrystParser::DefaultParamContext>(i);
}


size_t PrystParser::ParametersContext::getRuleIndex() const {
  return PrystParser::RuleParameters;
}


std::any PrystParser::ParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitParameters(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ParametersContext* PrystParser::parameters() {
  ParametersContext *_localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 14, PrystParser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(218);
    parameter();
    setState(223);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(219);
        match(PrystParser::COMMA);
        setState(220);
        parameter(); 
      }
      setState(225);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    }
    setState(230);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(226);
      match(PrystParser::COMMA);
      setState(227);
      defaultParam();
      setState(232);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

PrystParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::TypeContext* PrystParser::ParameterContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::ParameterContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}


size_t PrystParser::ParameterContext::getRuleIndex() const {
  return PrystParser::RuleParameter;
}


std::any PrystParser::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ParameterContext* PrystParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 16, PrystParser::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    type();
    setState(234);
    match(PrystParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultParamContext ------------------------------------------------------------------

PrystParser::DefaultParamContext::DefaultParamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::TypeContext* PrystParser::DefaultParamContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::DefaultParamContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::DefaultParamContext::ASSIGN() {
  return getToken(PrystParser::ASSIGN, 0);
}

PrystParser::LiteralContext* PrystParser::DefaultParamContext::literal() {
  return getRuleContext<PrystParser::LiteralContext>(0);
}

tree::TerminalNode* PrystParser::DefaultParamContext::NULL_LIT() {
  return getToken(PrystParser::NULL_LIT, 0);
}


size_t PrystParser::DefaultParamContext::getRuleIndex() const {
  return PrystParser::RuleDefaultParam;
}


std::any PrystParser::DefaultParamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitDefaultParam(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::DefaultParamContext* PrystParser::defaultParam() {
  DefaultParamContext *_localctx = _tracker.createInstance<DefaultParamContext>(_ctx, getState());
  enterRule(_localctx, 18, PrystParser::RuleDefaultParam);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(236);
    type();
    setState(237);
    match(PrystParser::IDENTIFIER);
    setState(238);
    match(PrystParser::ASSIGN);
    setState(241);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PrystParser::INTEGER:
      case PrystParser::FLOAT_LITERAL:
      case PrystParser::BOOLEAN:
      case PrystParser::STRING: {
        setState(239);
        literal();
        break;
      }

      case PrystParser::NULL_LIT: {
        setState(240);
        match(PrystParser::NULL_LIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

PrystParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::LiteralContext::INTEGER() {
  return getToken(PrystParser::INTEGER, 0);
}

tree::TerminalNode* PrystParser::LiteralContext::FLOAT_LITERAL() {
  return getToken(PrystParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* PrystParser::LiteralContext::STRING() {
  return getToken(PrystParser::STRING, 0);
}

tree::TerminalNode* PrystParser::LiteralContext::BOOLEAN() {
  return getToken(PrystParser::BOOLEAN, 0);
}


size_t PrystParser::LiteralContext::getRuleIndex() const {
  return PrystParser::RuleLiteral;
}


std::any PrystParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::LiteralContext* PrystParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 20, PrystParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(243);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 14) != 0) || _la == PrystParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

PrystParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::BlockContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::BlockContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

std::vector<PrystParser::StatementContext *> PrystParser::BlockContext::statement() {
  return getRuleContexts<PrystParser::StatementContext>();
}

PrystParser::StatementContext* PrystParser::BlockContext::statement(size_t i) {
  return getRuleContext<PrystParser::StatementContext>(i);
}


size_t PrystParser::BlockContext::getRuleIndex() const {
  return PrystParser::RuleBlock;
}


std::any PrystParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::BlockContext* PrystParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 22, PrystParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(245);
    match(PrystParser::LBRACE);
    setState(249);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4539618331716083714) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 7189) != 0)) {
      setState(246);
      statement();
      setState(251);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(252);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

PrystParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::BlockContext* PrystParser::StatementContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

PrystParser::VarDeclContext* PrystParser::StatementContext::varDecl() {
  return getRuleContext<PrystParser::VarDeclContext>(0);
}

PrystParser::AssignmentContext* PrystParser::StatementContext::assignment() {
  return getRuleContext<PrystParser::AssignmentContext>(0);
}

PrystParser::ExpressionStmtContext* PrystParser::StatementContext::expressionStmt() {
  return getRuleContext<PrystParser::ExpressionStmtContext>(0);
}

PrystParser::IfStmtContext* PrystParser::StatementContext::ifStmt() {
  return getRuleContext<PrystParser::IfStmtContext>(0);
}

PrystParser::WhileStmtContext* PrystParser::StatementContext::whileStmt() {
  return getRuleContext<PrystParser::WhileStmtContext>(0);
}

PrystParser::ForStmtContext* PrystParser::StatementContext::forStmt() {
  return getRuleContext<PrystParser::ForStmtContext>(0);
}

PrystParser::ReturnStmtContext* PrystParser::StatementContext::returnStmt() {
  return getRuleContext<PrystParser::ReturnStmtContext>(0);
}

PrystParser::TryStmtContext* PrystParser::StatementContext::tryStmt() {
  return getRuleContext<PrystParser::TryStmtContext>(0);
}

PrystParser::BreakStmtContext* PrystParser::StatementContext::breakStmt() {
  return getRuleContext<PrystParser::BreakStmtContext>(0);
}

PrystParser::ContinueStmtContext* PrystParser::StatementContext::continueStmt() {
  return getRuleContext<PrystParser::ContinueStmtContext>(0);
}

PrystParser::PrintStmtContext* PrystParser::StatementContext::printStmt() {
  return getRuleContext<PrystParser::PrintStmtContext>(0);
}


size_t PrystParser::StatementContext::getRuleIndex() const {
  return PrystParser::RuleStatement;
}


std::any PrystParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::StatementContext* PrystParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 24, PrystParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(254);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(255);
      varDecl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(256);
      assignment();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(257);
      expressionStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(258);
      ifStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(259);
      whileStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(260);
      forStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(261);
      returnStmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(262);
      tryStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(263);
      breakStmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(264);
      continueStmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(265);
      printStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclContext ------------------------------------------------------------------

PrystParser::VarDeclContext::VarDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::VarDeclContext::CONST() {
  return getToken(PrystParser::CONST, 0);
}

PrystParser::TypeContext* PrystParser::VarDeclContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

PrystParser::IdentifierListContext* PrystParser::VarDeclContext::identifierList() {
  return getRuleContext<PrystParser::IdentifierListContext>(0);
}

tree::TerminalNode* PrystParser::VarDeclContext::ASSIGN() {
  return getToken(PrystParser::ASSIGN, 0);
}

PrystParser::ExpressionContext* PrystParser::VarDeclContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::VarDeclContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

tree::TerminalNode* PrystParser::VarDeclContext::CONST_EXPR() {
  return getToken(PrystParser::CONST_EXPR, 0);
}

tree::TerminalNode* PrystParser::VarDeclContext::LET() {
  return getToken(PrystParser::LET, 0);
}


size_t PrystParser::VarDeclContext::getRuleIndex() const {
  return PrystParser::RuleVarDecl;
}


std::any PrystParser::VarDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitVarDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::VarDeclContext* PrystParser::varDecl() {
  VarDeclContext *_localctx = _tracker.createInstance<VarDeclContext>(_ctx, getState());
  enterRule(_localctx, 26, PrystParser::RuleVarDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(296);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PrystParser::CONST: {
        enterOuterAlt(_localctx, 1);
        setState(268);
        match(PrystParser::CONST);
        setState(269);
        type();
        setState(270);
        identifierList();
        setState(271);
        match(PrystParser::ASSIGN);
        setState(272);
        expression(0);
        setState(273);
        match(PrystParser::SEMICOLON);
        break;
      }

      case PrystParser::CONST_EXPR: {
        enterOuterAlt(_localctx, 2);
        setState(275);
        match(PrystParser::CONST_EXPR);
        setState(276);
        type();
        setState(277);
        identifierList();
        setState(278);
        match(PrystParser::ASSIGN);
        setState(279);
        expression(0);
        setState(280);
        match(PrystParser::SEMICOLON);
        break;
      }

      case PrystParser::LET: {
        enterOuterAlt(_localctx, 3);
        setState(282);
        match(PrystParser::LET);
        setState(283);
        identifierList();
        setState(284);
        match(PrystParser::ASSIGN);
        setState(285);
        expression(0);
        setState(286);
        match(PrystParser::SEMICOLON);
        break;
      }

      case PrystParser::INT:
      case PrystParser::FLOAT:
      case PrystParser::BOOL:
      case PrystParser::STR:
      case PrystParser::VOID:
      case PrystParser::FN:
      case PrystParser::MAP:
      case PrystParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 4);
        setState(288);
        type();
        setState(289);
        identifierList();
        setState(292);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PrystParser::ASSIGN) {
          setState(290);
          match(PrystParser::ASSIGN);
          setState(291);
          expression(0);
        }
        setState(294);
        match(PrystParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

PrystParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PrystParser::IdentifierListContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::IdentifierListContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> PrystParser::IdentifierListContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::IdentifierListContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::IdentifierListContext::getRuleIndex() const {
  return PrystParser::RuleIdentifierList;
}


std::any PrystParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::IdentifierListContext* PrystParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 28, PrystParser::RuleIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(PrystParser::IDENTIFIER);
    setState(303);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(299);
      match(PrystParser::COMMA);
      setState(300);
      match(PrystParser::IDENTIFIER);
      setState(305);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

PrystParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::ExpressionContext *> PrystParser::AssignmentContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::AssignmentContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::AssignmentContext::ASSIGN() {
  return getToken(PrystParser::ASSIGN, 0);
}

tree::TerminalNode* PrystParser::AssignmentContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}


size_t PrystParser::AssignmentContext::getRuleIndex() const {
  return PrystParser::RuleAssignment;
}


std::any PrystParser::AssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitAssignment(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::AssignmentContext* PrystParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 30, PrystParser::RuleAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    expression(0);
    setState(307);
    match(PrystParser::ASSIGN);
    setState(308);
    expression(0);
    setState(309);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtContext ------------------------------------------------------------------

PrystParser::IfStmtContext::IfStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::IfStmtContext::IF() {
  return getToken(PrystParser::IF, 0);
}

tree::TerminalNode* PrystParser::IfStmtContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::ExpressionContext* PrystParser::IfStmtContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::IfStmtContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

std::vector<PrystParser::StatementContext *> PrystParser::IfStmtContext::statement() {
  return getRuleContexts<PrystParser::StatementContext>();
}

PrystParser::StatementContext* PrystParser::IfStmtContext::statement(size_t i) {
  return getRuleContext<PrystParser::StatementContext>(i);
}

tree::TerminalNode* PrystParser::IfStmtContext::ELSE() {
  return getToken(PrystParser::ELSE, 0);
}


size_t PrystParser::IfStmtContext::getRuleIndex() const {
  return PrystParser::RuleIfStmt;
}


std::any PrystParser::IfStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitIfStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::IfStmtContext* PrystParser::ifStmt() {
  IfStmtContext *_localctx = _tracker.createInstance<IfStmtContext>(_ctx, getState());
  enterRule(_localctx, 32, PrystParser::RuleIfStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(311);
    match(PrystParser::IF);
    setState(312);
    match(PrystParser::LPAREN);
    setState(313);
    expression(0);
    setState(314);
    match(PrystParser::RPAREN);
    setState(315);
    statement();
    setState(318);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(316);
      match(PrystParser::ELSE);
      setState(317);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStmtContext ------------------------------------------------------------------

PrystParser::WhileStmtContext::WhileStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::WhileStmtContext::WHILE() {
  return getToken(PrystParser::WHILE, 0);
}

tree::TerminalNode* PrystParser::WhileStmtContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::ExpressionContext* PrystParser::WhileStmtContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::WhileStmtContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::StatementContext* PrystParser::WhileStmtContext::statement() {
  return getRuleContext<PrystParser::StatementContext>(0);
}


size_t PrystParser::WhileStmtContext::getRuleIndex() const {
  return PrystParser::RuleWhileStmt;
}


std::any PrystParser::WhileStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitWhileStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::WhileStmtContext* PrystParser::whileStmt() {
  WhileStmtContext *_localctx = _tracker.createInstance<WhileStmtContext>(_ctx, getState());
  enterRule(_localctx, 34, PrystParser::RuleWhileStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(320);
    match(PrystParser::WHILE);
    setState(321);
    match(PrystParser::LPAREN);
    setState(322);
    expression(0);
    setState(323);
    match(PrystParser::RPAREN);
    setState(324);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStmtContext ------------------------------------------------------------------

PrystParser::ForStmtContext::ForStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ForStmtContext::FOR() {
  return getToken(PrystParser::FOR, 0);
}

tree::TerminalNode* PrystParser::ForStmtContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ForStmtContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ForStmtContext::IN() {
  return getToken(PrystParser::IN, 0);
}

std::vector<PrystParser::ExpressionContext *> PrystParser::ForStmtContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::ForStmtContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::ForStmtContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::StatementContext* PrystParser::ForStmtContext::statement() {
  return getRuleContext<PrystParser::StatementContext>(0);
}

tree::TerminalNode* PrystParser::ForStmtContext::LET() {
  return getToken(PrystParser::LET, 0);
}

PrystParser::TypeContext* PrystParser::ForStmtContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

std::vector<tree::TerminalNode *> PrystParser::ForStmtContext::SEMICOLON() {
  return getTokens(PrystParser::SEMICOLON);
}

tree::TerminalNode* PrystParser::ForStmtContext::SEMICOLON(size_t i) {
  return getToken(PrystParser::SEMICOLON, i);
}

PrystParser::VarDeclContext* PrystParser::ForStmtContext::varDecl() {
  return getRuleContext<PrystParser::VarDeclContext>(0);
}

PrystParser::ExpressionStmtContext* PrystParser::ForStmtContext::expressionStmt() {
  return getRuleContext<PrystParser::ExpressionStmtContext>(0);
}


size_t PrystParser::ForStmtContext::getRuleIndex() const {
  return PrystParser::RuleForStmt;
}


std::any PrystParser::ForStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitForStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ForStmtContext* PrystParser::forStmt() {
  ForStmtContext *_localctx = _tracker.createInstance<ForStmtContext>(_ctx, getState());
  enterRule(_localctx, 36, PrystParser::RuleForStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(354);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(326);
      match(PrystParser::FOR);
      setState(327);
      match(PrystParser::LPAREN);
      setState(330);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PrystParser::LET: {
          setState(328);
          match(PrystParser::LET);
          break;
        }

        case PrystParser::INT:
        case PrystParser::FLOAT:
        case PrystParser::BOOL:
        case PrystParser::STR:
        case PrystParser::VOID:
        case PrystParser::FN:
        case PrystParser::MAP:
        case PrystParser::IDENTIFIER: {
          setState(329);
          type();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(332);
      match(PrystParser::IDENTIFIER);
      setState(333);
      match(PrystParser::IN);
      setState(334);
      expression(0);
      setState(335);
      match(PrystParser::RPAREN);
      setState(336);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(338);
      match(PrystParser::FOR);
      setState(339);
      match(PrystParser::LPAREN);
      setState(343);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
      case 1: {
        setState(340);
        varDecl();
        break;
      }

      case 2: {
        setState(341);
        expressionStmt();
        break;
      }

      case 3: {
        setState(342);
        match(PrystParser::SEMICOLON);
        break;
      }

      default:
        break;
      }
      setState(346);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(345);
        expression(0);
      }
      setState(348);
      match(PrystParser::SEMICOLON);
      setState(350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(349);
        expression(0);
      }
      setState(352);
      match(PrystParser::RPAREN);
      setState(353);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext ------------------------------------------------------------------

PrystParser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ReturnStmtContext::RETURN() {
  return getToken(PrystParser::RETURN, 0);
}

tree::TerminalNode* PrystParser::ReturnStmtContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

PrystParser::ExpressionContext* PrystParser::ReturnStmtContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}


size_t PrystParser::ReturnStmtContext::getRuleIndex() const {
  return PrystParser::RuleReturnStmt;
}


std::any PrystParser::ReturnStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitReturnStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ReturnStmtContext* PrystParser::returnStmt() {
  ReturnStmtContext *_localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 38, PrystParser::RuleReturnStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    match(PrystParser::RETURN);
    setState(358);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 7189) != 0)) {
      setState(357);
      expression(0);
    }
    setState(360);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStmtContext ------------------------------------------------------------------

PrystParser::TryStmtContext::TryStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::TryStmtContext::TRY() {
  return getToken(PrystParser::TRY, 0);
}

std::vector<PrystParser::BlockContext *> PrystParser::TryStmtContext::block() {
  return getRuleContexts<PrystParser::BlockContext>();
}

PrystParser::BlockContext* PrystParser::TryStmtContext::block(size_t i) {
  return getRuleContext<PrystParser::BlockContext>(i);
}

std::vector<PrystParser::CatchClauseContext *> PrystParser::TryStmtContext::catchClause() {
  return getRuleContexts<PrystParser::CatchClauseContext>();
}

PrystParser::CatchClauseContext* PrystParser::TryStmtContext::catchClause(size_t i) {
  return getRuleContext<PrystParser::CatchClauseContext>(i);
}

tree::TerminalNode* PrystParser::TryStmtContext::FINALLY() {
  return getToken(PrystParser::FINALLY, 0);
}


size_t PrystParser::TryStmtContext::getRuleIndex() const {
  return PrystParser::RuleTryStmt;
}


std::any PrystParser::TryStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitTryStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::TryStmtContext* PrystParser::tryStmt() {
  TryStmtContext *_localctx = _tracker.createInstance<TryStmtContext>(_ctx, getState());
  enterRule(_localctx, 40, PrystParser::RuleTryStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(362);
    match(PrystParser::TRY);
    setState(363);
    block();
    setState(367);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::CATCH) {
      setState(364);
      catchClause();
      setState(369);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(372);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::FINALLY) {
      setState(370);
      match(PrystParser::FINALLY);
      setState(371);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchClauseContext ------------------------------------------------------------------

PrystParser::CatchClauseContext::CatchClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::CatchClauseContext::CATCH() {
  return getToken(PrystParser::CATCH, 0);
}

tree::TerminalNode* PrystParser::CatchClauseContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::TypeContext* PrystParser::CatchClauseContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::CatchClauseContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::CatchClauseContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::BlockContext* PrystParser::CatchClauseContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

tree::TerminalNode* PrystParser::CatchClauseContext::CHAIN() {
  return getToken(PrystParser::CHAIN, 0);
}

PrystParser::ExpressionContext* PrystParser::CatchClauseContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}


size_t PrystParser::CatchClauseContext::getRuleIndex() const {
  return PrystParser::RuleCatchClause;
}


std::any PrystParser::CatchClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitCatchClause(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::CatchClauseContext* PrystParser::catchClause() {
  CatchClauseContext *_localctx = _tracker.createInstance<CatchClauseContext>(_ctx, getState());
  enterRule(_localctx, 42, PrystParser::RuleCatchClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(374);
    match(PrystParser::CATCH);
    setState(375);
    match(PrystParser::LPAREN);
    setState(376);
    type();
    setState(377);
    match(PrystParser::IDENTIFIER);
    setState(380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::CHAIN) {
      setState(378);
      match(PrystParser::CHAIN);
      setState(379);
      expression(0);
    }
    setState(382);
    match(PrystParser::RPAREN);
    setState(383);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStmtContext ------------------------------------------------------------------

PrystParser::BreakStmtContext::BreakStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::BreakStmtContext::BREAK() {
  return getToken(PrystParser::BREAK, 0);
}

tree::TerminalNode* PrystParser::BreakStmtContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}


size_t PrystParser::BreakStmtContext::getRuleIndex() const {
  return PrystParser::RuleBreakStmt;
}


std::any PrystParser::BreakStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitBreakStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::BreakStmtContext* PrystParser::breakStmt() {
  BreakStmtContext *_localctx = _tracker.createInstance<BreakStmtContext>(_ctx, getState());
  enterRule(_localctx, 44, PrystParser::RuleBreakStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    match(PrystParser::BREAK);
    setState(386);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStmtContext ------------------------------------------------------------------

PrystParser::ContinueStmtContext::ContinueStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ContinueStmtContext::CONTINUE() {
  return getToken(PrystParser::CONTINUE, 0);
}

tree::TerminalNode* PrystParser::ContinueStmtContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}


size_t PrystParser::ContinueStmtContext::getRuleIndex() const {
  return PrystParser::RuleContinueStmt;
}


std::any PrystParser::ContinueStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitContinueStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ContinueStmtContext* PrystParser::continueStmt() {
  ContinueStmtContext *_localctx = _tracker.createInstance<ContinueStmtContext>(_ctx, getState());
  enterRule(_localctx, 46, PrystParser::RuleContinueStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(388);
    match(PrystParser::CONTINUE);
    setState(389);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrintStmtContext ------------------------------------------------------------------

PrystParser::PrintStmtContext::PrintStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::PrintStmtContext::PRINT() {
  return getToken(PrystParser::PRINT, 0);
}

tree::TerminalNode* PrystParser::PrintStmtContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::ExpressionContext* PrystParser::PrintStmtContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::PrintStmtContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

tree::TerminalNode* PrystParser::PrintStmtContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}


size_t PrystParser::PrintStmtContext::getRuleIndex() const {
  return PrystParser::RulePrintStmt;
}


std::any PrystParser::PrintStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPrintStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::PrintStmtContext* PrystParser::printStmt() {
  PrintStmtContext *_localctx = _tracker.createInstance<PrintStmtContext>(_ctx, getState());
  enterRule(_localctx, 48, PrystParser::RulePrintStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(391);
    match(PrystParser::PRINT);
    setState(392);
    match(PrystParser::LPAREN);
    setState(393);
    expression(0);
    setState(394);
    match(PrystParser::RPAREN);
    setState(395);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStmtContext ------------------------------------------------------------------

PrystParser::ExpressionStmtContext::ExpressionStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::ExpressionContext* PrystParser::ExpressionStmtContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::ExpressionStmtContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}


size_t PrystParser::ExpressionStmtContext::getRuleIndex() const {
  return PrystParser::RuleExpressionStmt;
}


std::any PrystParser::ExpressionStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitExpressionStmt(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ExpressionStmtContext* PrystParser::expressionStmt() {
  ExpressionStmtContext *_localctx = _tracker.createInstance<ExpressionStmtContext>(_ctx, getState());
  enterRule(_localctx, 50, PrystParser::RuleExpressionStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    expression(0);
    setState(398);
    match(PrystParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclContext ------------------------------------------------------------------

PrystParser::ClassDeclContext::ClassDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ClassDeclContext::CLASS() {
  return getToken(PrystParser::CLASS, 0);
}

std::vector<tree::TerminalNode *> PrystParser::ClassDeclContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::ClassDeclContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

tree::TerminalNode* PrystParser::ClassDeclContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::ClassDeclContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

PrystParser::GenericParamsContext* PrystParser::ClassDeclContext::genericParams() {
  return getRuleContext<PrystParser::GenericParamsContext>(0);
}

tree::TerminalNode* PrystParser::ClassDeclContext::EXTENDS() {
  return getToken(PrystParser::EXTENDS, 0);
}

tree::TerminalNode* PrystParser::ClassDeclContext::IMPLEMENTS() {
  return getToken(PrystParser::IMPLEMENTS, 0);
}

std::vector<PrystParser::ConstructorDeclContext *> PrystParser::ClassDeclContext::constructorDecl() {
  return getRuleContexts<PrystParser::ConstructorDeclContext>();
}

PrystParser::ConstructorDeclContext* PrystParser::ClassDeclContext::constructorDecl(size_t i) {
  return getRuleContext<PrystParser::ConstructorDeclContext>(i);
}

std::vector<PrystParser::ClassMemberContext *> PrystParser::ClassDeclContext::classMember() {
  return getRuleContexts<PrystParser::ClassMemberContext>();
}

PrystParser::ClassMemberContext* PrystParser::ClassDeclContext::classMember(size_t i) {
  return getRuleContext<PrystParser::ClassMemberContext>(i);
}

std::vector<PrystParser::GenericArgsContext *> PrystParser::ClassDeclContext::genericArgs() {
  return getRuleContexts<PrystParser::GenericArgsContext>();
}

PrystParser::GenericArgsContext* PrystParser::ClassDeclContext::genericArgs(size_t i) {
  return getRuleContext<PrystParser::GenericArgsContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::ClassDeclContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::ClassDeclContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::ClassDeclContext::getRuleIndex() const {
  return PrystParser::RuleClassDecl;
}


std::any PrystParser::ClassDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitClassDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ClassDeclContext* PrystParser::classDecl() {
  ClassDeclContext *_localctx = _tracker.createInstance<ClassDeclContext>(_ctx, getState());
  enterRule(_localctx, 52, PrystParser::RuleClassDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(400);
    match(PrystParser::CLASS);
    setState(401);
    match(PrystParser::IDENTIFIER);
    setState(403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::LT) {
      setState(402);
      genericParams();
    }
    setState(410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::EXTENDS) {
      setState(405);
      match(PrystParser::EXTENDS);
      setState(406);
      match(PrystParser::IDENTIFIER);
      setState(408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::LT) {
        setState(407);
        genericArgs();
      }
    }
    setState(427);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::IMPLEMENTS) {
      setState(412);
      match(PrystParser::IMPLEMENTS);
      setState(413);
      match(PrystParser::IDENTIFIER);
      setState(415);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::LT) {
        setState(414);
        genericArgs();
      }
      setState(424);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PrystParser::COMMA) {
        setState(417);
        match(PrystParser::COMMA);
        setState(418);
        match(PrystParser::IDENTIFIER);
        setState(420);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PrystParser::LT) {
          setState(419);
          genericArgs();
        }
        setState(426);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(429);
    match(PrystParser::LBRACE);
    setState(434);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4294974448) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(432);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(430);
        constructorDecl();
        break;
      }

      case 2: {
        setState(431);
        classMember();
        break;
      }

      default:
        break;
      }
      setState(436);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(437);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceDeclContext ------------------------------------------------------------------

PrystParser::InterfaceDeclContext::InterfaceDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::INTERFACE() {
  return getToken(PrystParser::INTERFACE, 0);
}

std::vector<tree::TerminalNode *> PrystParser::InterfaceDeclContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

PrystParser::GenericParamsContext* PrystParser::InterfaceDeclContext::genericParams() {
  return getRuleContext<PrystParser::GenericParamsContext>(0);
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::EXTENDS() {
  return getToken(PrystParser::EXTENDS, 0);
}

std::vector<PrystParser::InterfaceMemberContext *> PrystParser::InterfaceDeclContext::interfaceMember() {
  return getRuleContexts<PrystParser::InterfaceMemberContext>();
}

PrystParser::InterfaceMemberContext* PrystParser::InterfaceDeclContext::interfaceMember(size_t i) {
  return getRuleContext<PrystParser::InterfaceMemberContext>(i);
}

std::vector<PrystParser::GenericArgsContext *> PrystParser::InterfaceDeclContext::genericArgs() {
  return getRuleContexts<PrystParser::GenericArgsContext>();
}

PrystParser::GenericArgsContext* PrystParser::InterfaceDeclContext::genericArgs(size_t i) {
  return getRuleContext<PrystParser::GenericArgsContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::InterfaceDeclContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::InterfaceDeclContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::InterfaceDeclContext::getRuleIndex() const {
  return PrystParser::RuleInterfaceDecl;
}


std::any PrystParser::InterfaceDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitInterfaceDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::InterfaceDeclContext* PrystParser::interfaceDecl() {
  InterfaceDeclContext *_localctx = _tracker.createInstance<InterfaceDeclContext>(_ctx, getState());
  enterRule(_localctx, 54, PrystParser::RuleInterfaceDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(439);
    match(PrystParser::INTERFACE);
    setState(440);
    match(PrystParser::IDENTIFIER);
    setState(442);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::LT) {
      setState(441);
      genericParams();
    }
    setState(459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PrystParser::EXTENDS) {
      setState(444);
      match(PrystParser::EXTENDS);
      setState(445);
      match(PrystParser::IDENTIFIER);
      setState(447);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::LT) {
        setState(446);
        genericArgs();
      }
      setState(456);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == PrystParser::COMMA) {
        setState(449);
        match(PrystParser::COMMA);
        setState(450);
        match(PrystParser::IDENTIFIER);
        setState(452);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PrystParser::LT) {
          setState(451);
          genericArgs();
        }
        setState(458);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(461);
    match(PrystParser::LBRACE);
    setState(465);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(462);
      interfaceMember();
      setState(467);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(468);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceMemberContext ------------------------------------------------------------------

PrystParser::InterfaceMemberContext::InterfaceMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::ReturnTypeContext* PrystParser::InterfaceMemberContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

tree::TerminalNode* PrystParser::InterfaceMemberContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::InterfaceMemberContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::InterfaceMemberContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

tree::TerminalNode* PrystParser::InterfaceMemberContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

PrystParser::ParametersContext* PrystParser::InterfaceMemberContext::parameters() {
  return getRuleContext<PrystParser::ParametersContext>(0);
}


size_t PrystParser::InterfaceMemberContext::getRuleIndex() const {
  return PrystParser::RuleInterfaceMember;
}


std::any PrystParser::InterfaceMemberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitInterfaceMember(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::InterfaceMemberContext* PrystParser::interfaceMember() {
  InterfaceMemberContext *_localctx = _tracker.createInstance<InterfaceMemberContext>(_ctx, getState());
  enterRule(_localctx, 56, PrystParser::RuleInterfaceMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(483);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(470);
      returnType();
      setState(471);
      match(PrystParser::IDENTIFIER);
      setState(472);
      match(PrystParser::LPAREN);
      setState(474);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
        setState(473);
        parameters();
      }
      setState(476);
      match(PrystParser::RPAREN);
      setState(477);
      match(PrystParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(479);
      returnType();
      setState(480);
      match(PrystParser::IDENTIFIER);
      setState(481);
      match(PrystParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericParamsContext ------------------------------------------------------------------

PrystParser::GenericParamsContext::GenericParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::GenericParamsContext::LT() {
  return getToken(PrystParser::LT, 0);
}

std::vector<tree::TerminalNode *> PrystParser::GenericParamsContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::GenericParamsContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

tree::TerminalNode* PrystParser::GenericParamsContext::GT() {
  return getToken(PrystParser::GT, 0);
}

std::vector<tree::TerminalNode *> PrystParser::GenericParamsContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::GenericParamsContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::GenericParamsContext::getRuleIndex() const {
  return PrystParser::RuleGenericParams;
}


std::any PrystParser::GenericParamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitGenericParams(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::GenericParamsContext* PrystParser::genericParams() {
  GenericParamsContext *_localctx = _tracker.createInstance<GenericParamsContext>(_ctx, getState());
  enterRule(_localctx, 58, PrystParser::RuleGenericParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(485);
    match(PrystParser::LT);
    setState(486);
    match(PrystParser::IDENTIFIER);
    setState(491);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(487);
      match(PrystParser::COMMA);
      setState(488);
      match(PrystParser::IDENTIFIER);
      setState(493);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(494);
    match(PrystParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericArgsContext ------------------------------------------------------------------

PrystParser::GenericArgsContext::GenericArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::GenericArgsContext::LT() {
  return getToken(PrystParser::LT, 0);
}

std::vector<PrystParser::TypeContext *> PrystParser::GenericArgsContext::type() {
  return getRuleContexts<PrystParser::TypeContext>();
}

PrystParser::TypeContext* PrystParser::GenericArgsContext::type(size_t i) {
  return getRuleContext<PrystParser::TypeContext>(i);
}

tree::TerminalNode* PrystParser::GenericArgsContext::GT() {
  return getToken(PrystParser::GT, 0);
}

std::vector<tree::TerminalNode *> PrystParser::GenericArgsContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::GenericArgsContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::GenericArgsContext::getRuleIndex() const {
  return PrystParser::RuleGenericArgs;
}


std::any PrystParser::GenericArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitGenericArgs(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::GenericArgsContext* PrystParser::genericArgs() {
  GenericArgsContext *_localctx = _tracker.createInstance<GenericArgsContext>(_ctx, getState());
  enterRule(_localctx, 60, PrystParser::RuleGenericArgs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(PrystParser::LT);
    setState(497);
    type();
    setState(502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(498);
      match(PrystParser::COMMA);
      setState(499);
      type();
      setState(504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(505);
    match(PrystParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassMemberContext ------------------------------------------------------------------

PrystParser::ClassMemberContext::ClassMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::TypeContext* PrystParser::ClassMemberContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::CONST() {
  return getToken(PrystParser::CONST, 0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::CONST_EXPR() {
  return getToken(PrystParser::CONST_EXPR, 0);
}

PrystParser::ReturnTypeContext* PrystParser::ClassMemberContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ClassMemberContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::BlockContext* PrystParser::ClassMemberContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

PrystParser::GenericParamsContext* PrystParser::ClassMemberContext::genericParams() {
  return getRuleContext<PrystParser::GenericParamsContext>(0);
}

PrystParser::ParametersContext* PrystParser::ClassMemberContext::parameters() {
  return getRuleContext<PrystParser::ParametersContext>(0);
}

PrystParser::OverloadParamsContext* PrystParser::ClassMemberContext::overloadParams() {
  return getRuleContext<PrystParser::OverloadParamsContext>(0);
}


size_t PrystParser::ClassMemberContext::getRuleIndex() const {
  return PrystParser::RuleClassMember;
}


std::any PrystParser::ClassMemberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitClassMember(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ClassMemberContext* PrystParser::classMember() {
  ClassMemberContext *_localctx = _tracker.createInstance<ClassMemberContext>(_ctx, getState());
  enterRule(_localctx, 62, PrystParser::RuleClassMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(535);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(508);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::CONST

      || _la == PrystParser::CONST_EXPR) {
        setState(507);
        _la = _input->LA(1);
        if (!(_la == PrystParser::CONST

        || _la == PrystParser::CONST_EXPR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(510);
      type();
      setState(511);
      match(PrystParser::IDENTIFIER);
      setState(512);
      match(PrystParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(514);
      returnType();
      setState(515);
      match(PrystParser::IDENTIFIER);
      setState(517);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::LT) {
        setState(516);
        genericParams();
      }
      setState(519);
      match(PrystParser::LPAREN);
      setState(521);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
        setState(520);
        parameters();
      }
      setState(523);
      match(PrystParser::RPAREN);
      setState(524);
      block();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(526);
      returnType();
      setState(527);
      match(PrystParser::IDENTIFIER);
      setState(528);
      match(PrystParser::LPAREN);
      setState(530);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
        setState(529);
        overloadParams();
      }
      setState(532);
      match(PrystParser::RPAREN);
      setState(533);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OverloadParamsContext ------------------------------------------------------------------

PrystParser::OverloadParamsContext::OverloadParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::ParameterContext *> PrystParser::OverloadParamsContext::parameter() {
  return getRuleContexts<PrystParser::ParameterContext>();
}

PrystParser::ParameterContext* PrystParser::OverloadParamsContext::parameter(size_t i) {
  return getRuleContext<PrystParser::ParameterContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::OverloadParamsContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::OverloadParamsContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::OverloadParamsContext::getRuleIndex() const {
  return PrystParser::RuleOverloadParams;
}


std::any PrystParser::OverloadParamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitOverloadParams(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::OverloadParamsContext* PrystParser::overloadParams() {
  OverloadParamsContext *_localctx = _tracker.createInstance<OverloadParamsContext>(_ctx, getState());
  enterRule(_localctx, 64, PrystParser::RuleOverloadParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(537);
    parameter();
    setState(542);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(538);
      match(PrystParser::COMMA);
      setState(539);
      parameter();
      setState(544);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorDeclContext ------------------------------------------------------------------

PrystParser::ConstructorDeclContext::ConstructorDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ConstructorDeclContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ConstructorDeclContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ConstructorDeclContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::ConstructorBlockContext* PrystParser::ConstructorDeclContext::constructorBlock() {
  return getRuleContext<PrystParser::ConstructorBlockContext>(0);
}

PrystParser::ParametersContext* PrystParser::ConstructorDeclContext::parameters() {
  return getRuleContext<PrystParser::ParametersContext>(0);
}


size_t PrystParser::ConstructorDeclContext::getRuleIndex() const {
  return PrystParser::RuleConstructorDecl;
}


std::any PrystParser::ConstructorDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitConstructorDecl(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ConstructorDeclContext* PrystParser::constructorDecl() {
  ConstructorDeclContext *_localctx = _tracker.createInstance<ConstructorDeclContext>(_ctx, getState());
  enterRule(_localctx, 66, PrystParser::RuleConstructorDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(545);
    match(PrystParser::IDENTIFIER);
    setState(546);
    match(PrystParser::LPAREN);
    setState(548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(547);
      parameters();
    }
    setState(550);
    match(PrystParser::RPAREN);
    setState(551);
    constructorBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorBlockContext ------------------------------------------------------------------

PrystParser::ConstructorBlockContext::ConstructorBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> PrystParser::ConstructorBlockContext::THIS() {
  return getTokens(PrystParser::THIS);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::THIS(size_t i) {
  return getToken(PrystParser::THIS, i);
}

std::vector<tree::TerminalNode *> PrystParser::ConstructorBlockContext::DOT() {
  return getTokens(PrystParser::DOT);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::DOT(size_t i) {
  return getToken(PrystParser::DOT, i);
}

std::vector<tree::TerminalNode *> PrystParser::ConstructorBlockContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> PrystParser::ConstructorBlockContext::ASSIGN() {
  return getTokens(PrystParser::ASSIGN);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::ASSIGN(size_t i) {
  return getToken(PrystParser::ASSIGN, i);
}

std::vector<PrystParser::ExpressionContext *> PrystParser::ConstructorBlockContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::ConstructorBlockContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::ConstructorBlockContext::SEMICOLON() {
  return getTokens(PrystParser::SEMICOLON);
}

tree::TerminalNode* PrystParser::ConstructorBlockContext::SEMICOLON(size_t i) {
  return getToken(PrystParser::SEMICOLON, i);
}

std::vector<PrystParser::StatementContext *> PrystParser::ConstructorBlockContext::statement() {
  return getRuleContexts<PrystParser::StatementContext>();
}

PrystParser::StatementContext* PrystParser::ConstructorBlockContext::statement(size_t i) {
  return getRuleContext<PrystParser::StatementContext>(i);
}


size_t PrystParser::ConstructorBlockContext::getRuleIndex() const {
  return PrystParser::RuleConstructorBlock;
}


std::any PrystParser::ConstructorBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitConstructorBlock(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ConstructorBlockContext* PrystParser::constructorBlock() {
  ConstructorBlockContext *_localctx = _tracker.createInstance<ConstructorBlockContext>(_ctx, getState());
  enterRule(_localctx, 68, PrystParser::RuleConstructorBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(553);
    match(PrystParser::LBRACE);
    setState(564);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4539618331716083714) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 7189) != 0)) {
      setState(562);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
      case 1: {
        setState(554);
        match(PrystParser::THIS);
        setState(555);
        match(PrystParser::DOT);
        setState(556);
        match(PrystParser::IDENTIFIER);
        setState(557);
        match(PrystParser::ASSIGN);
        setState(558);
        expression(0);
        setState(559);
        match(PrystParser::SEMICOLON);
        break;
      }

      case 2: {
        setState(561);
        statement();
        break;
      }

      default:
        break;
      }
      setState(566);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(567);
    match(PrystParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

PrystParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::PrimaryTypeContext* PrystParser::TypeContext::primaryType() {
  return getRuleContext<PrystParser::PrimaryTypeContext>(0);
}

std::vector<PrystParser::TypeRestContext *> PrystParser::TypeContext::typeRest() {
  return getRuleContexts<PrystParser::TypeRestContext>();
}

PrystParser::TypeRestContext* PrystParser::TypeContext::typeRest(size_t i) {
  return getRuleContext<PrystParser::TypeRestContext>(i);
}


size_t PrystParser::TypeContext::getRuleIndex() const {
  return PrystParser::RuleType;
}


std::any PrystParser::TypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::TypeContext* PrystParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 70, PrystParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(569);
    primaryType();
    setState(573);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(570);
        typeRest(); 
      }
      setState(575);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeRestContext ------------------------------------------------------------------

PrystParser::TypeRestContext::TypeRestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::TypeRestContext::PIPE() {
  return getToken(PrystParser::PIPE, 0);
}

PrystParser::PrimaryTypeContext* PrystParser::TypeRestContext::primaryType() {
  return getRuleContext<PrystParser::PrimaryTypeContext>(0);
}

tree::TerminalNode* PrystParser::TypeRestContext::AMP() {
  return getToken(PrystParser::AMP, 0);
}


size_t PrystParser::TypeRestContext::getRuleIndex() const {
  return PrystParser::RuleTypeRest;
}


std::any PrystParser::TypeRestContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitTypeRest(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::TypeRestContext* PrystParser::typeRest() {
  TypeRestContext *_localctx = _tracker.createInstance<TypeRestContext>(_ctx, getState());
  enterRule(_localctx, 72, PrystParser::RuleTypeRest);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(580);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PrystParser::PIPE: {
        enterOuterAlt(_localctx, 1);
        setState(576);
        match(PrystParser::PIPE);
        setState(577);
        primaryType();
        break;
      }

      case PrystParser::AMP: {
        enterOuterAlt(_localctx, 2);
        setState(578);
        match(PrystParser::AMP);
        setState(579);
        primaryType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryTypeContext ------------------------------------------------------------------

PrystParser::PrimaryTypeContext::PrimaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::NullableTypeContext* PrystParser::PrimaryTypeContext::nullableType() {
  return getRuleContext<PrystParser::NullableTypeContext>(0);
}

PrystParser::QualifiedTypeContext* PrystParser::PrimaryTypeContext::qualifiedType() {
  return getRuleContext<PrystParser::QualifiedTypeContext>(0);
}

PrystParser::GenericArgsContext* PrystParser::PrimaryTypeContext::genericArgs() {
  return getRuleContext<PrystParser::GenericArgsContext>(0);
}

PrystParser::FunctionTypeContext* PrystParser::PrimaryTypeContext::functionType() {
  return getRuleContext<PrystParser::FunctionTypeContext>(0);
}

PrystParser::ArrayTypeContext* PrystParser::PrimaryTypeContext::arrayType() {
  return getRuleContext<PrystParser::ArrayTypeContext>(0);
}

PrystParser::MapTypeContext* PrystParser::PrimaryTypeContext::mapType() {
  return getRuleContext<PrystParser::MapTypeContext>(0);
}

PrystParser::BasicTypeContext* PrystParser::PrimaryTypeContext::basicType() {
  return getRuleContext<PrystParser::BasicTypeContext>(0);
}


size_t PrystParser::PrimaryTypeContext::getRuleIndex() const {
  return PrystParser::RulePrimaryType;
}


std::any PrystParser::PrimaryTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::PrimaryTypeContext* PrystParser::primaryType() {
  PrimaryTypeContext *_localctx = _tracker.createInstance<PrimaryTypeContext>(_ctx, getState());
  enterRule(_localctx, 74, PrystParser::RulePrimaryType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(591);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(582);
      nullableType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(583);
      qualifiedType();
      setState(585);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
      case 1: {
        setState(584);
        genericArgs();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(587);
      functionType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(588);
      arrayType(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(589);
      mapType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(590);
      basicType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedTypeContext ------------------------------------------------------------------

PrystParser::QualifiedTypeContext::QualifiedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PrystParser::QualifiedTypeContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::QualifiedTypeContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> PrystParser::QualifiedTypeContext::DOUBLE_COLON() {
  return getTokens(PrystParser::DOUBLE_COLON);
}

tree::TerminalNode* PrystParser::QualifiedTypeContext::DOUBLE_COLON(size_t i) {
  return getToken(PrystParser::DOUBLE_COLON, i);
}


size_t PrystParser::QualifiedTypeContext::getRuleIndex() const {
  return PrystParser::RuleQualifiedType;
}


std::any PrystParser::QualifiedTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::QualifiedTypeContext* PrystParser::qualifiedType() {
  QualifiedTypeContext *_localctx = _tracker.createInstance<QualifiedTypeContext>(_ctx, getState());
  enterRule(_localctx, 76, PrystParser::RuleQualifiedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(593);
    match(PrystParser::IDENTIFIER);
    setState(598);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(594);
        match(PrystParser::DOUBLE_COLON);
        setState(595);
        match(PrystParser::IDENTIFIER); 
      }
      setState(600);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnTypeContext ------------------------------------------------------------------

PrystParser::ReturnTypeContext::ReturnTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::TypeContext* PrystParser::ReturnTypeContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::ReturnTypeContext::VOID() {
  return getToken(PrystParser::VOID, 0);
}


size_t PrystParser::ReturnTypeContext::getRuleIndex() const {
  return PrystParser::RuleReturnType;
}


std::any PrystParser::ReturnTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitReturnType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ReturnTypeContext* PrystParser::returnType() {
  ReturnTypeContext *_localctx = _tracker.createInstance<ReturnTypeContext>(_ctx, getState());
  enterRule(_localctx, 78, PrystParser::RuleReturnType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(603);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(601);
      type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(602);
      match(PrystParser::VOID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullableTypeContext ------------------------------------------------------------------

PrystParser::NullableTypeContext::NullableTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::NullableTypeContext::QUESTION_MARK() {
  return getToken(PrystParser::QUESTION_MARK, 0);
}

PrystParser::QualifiedTypeContext* PrystParser::NullableTypeContext::qualifiedType() {
  return getRuleContext<PrystParser::QualifiedTypeContext>(0);
}

PrystParser::FunctionTypeContext* PrystParser::NullableTypeContext::functionType() {
  return getRuleContext<PrystParser::FunctionTypeContext>(0);
}

PrystParser::ArrayTypeContext* PrystParser::NullableTypeContext::arrayType() {
  return getRuleContext<PrystParser::ArrayTypeContext>(0);
}

PrystParser::MapTypeContext* PrystParser::NullableTypeContext::mapType() {
  return getRuleContext<PrystParser::MapTypeContext>(0);
}

PrystParser::BasicTypeContext* PrystParser::NullableTypeContext::basicType() {
  return getRuleContext<PrystParser::BasicTypeContext>(0);
}


size_t PrystParser::NullableTypeContext::getRuleIndex() const {
  return PrystParser::RuleNullableType;
}


std::any PrystParser::NullableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNullableType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::NullableTypeContext* PrystParser::nullableType() {
  NullableTypeContext *_localctx = _tracker.createInstance<NullableTypeContext>(_ctx, getState());
  enterRule(_localctx, 80, PrystParser::RuleNullableType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(605);
      qualifiedType();
      break;
    }

    case 2: {
      setState(606);
      functionType();
      break;
    }

    case 3: {
      setState(607);
      arrayType(0);
      break;
    }

    case 4: {
      setState(608);
      mapType();
      break;
    }

    case 5: {
      setState(609);
      basicType();
      break;
    }

    default:
      break;
    }
    setState(612);
    match(PrystParser::QUESTION_MARK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BasicTypeContext ------------------------------------------------------------------

PrystParser::BasicTypeContext::BasicTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::BasicTypeContext::STR() {
  return getToken(PrystParser::STR, 0);
}

tree::TerminalNode* PrystParser::BasicTypeContext::INT() {
  return getToken(PrystParser::INT, 0);
}

tree::TerminalNode* PrystParser::BasicTypeContext::FLOAT() {
  return getToken(PrystParser::FLOAT, 0);
}

tree::TerminalNode* PrystParser::BasicTypeContext::BOOL() {
  return getToken(PrystParser::BOOL, 0);
}

tree::TerminalNode* PrystParser::BasicTypeContext::VOID() {
  return getToken(PrystParser::VOID, 0);
}

tree::TerminalNode* PrystParser::BasicTypeContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}


size_t PrystParser::BasicTypeContext::getRuleIndex() const {
  return PrystParser::RuleBasicType;
}


std::any PrystParser::BasicTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitBasicType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::BasicTypeContext* PrystParser::basicType() {
  BasicTypeContext *_localctx = _tracker.createInstance<BasicTypeContext>(_ctx, getState());
  enterRule(_localctx, 82, PrystParser::RuleBasicType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 496) != 0) || _la == PrystParser::IDENTIFIER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

PrystParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PrystParser::BasicTypeContext* PrystParser::ArrayTypeContext::basicType() {
  return getRuleContext<PrystParser::BasicTypeContext>(0);
}

tree::TerminalNode* PrystParser::ArrayTypeContext::LBRACK() {
  return getToken(PrystParser::LBRACK, 0);
}

tree::TerminalNode* PrystParser::ArrayTypeContext::RBRACK() {
  return getToken(PrystParser::RBRACK, 0);
}

PrystParser::ArrayTypeContext* PrystParser::ArrayTypeContext::arrayType() {
  return getRuleContext<PrystParser::ArrayTypeContext>(0);
}


size_t PrystParser::ArrayTypeContext::getRuleIndex() const {
  return PrystParser::RuleArrayType;
}


std::any PrystParser::ArrayTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitArrayType(this);
  else
    return visitor->visitChildren(this);
}


PrystParser::ArrayTypeContext* PrystParser::arrayType() {
   return arrayType(0);
}

PrystParser::ArrayTypeContext* PrystParser::arrayType(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PrystParser::ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, parentState);
  PrystParser::ArrayTypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 84;
  enterRecursionRule(_localctx, 84, PrystParser::RuleArrayType, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(617);
    basicType();
    setState(618);
    match(PrystParser::LBRACK);
    setState(619);
    match(PrystParser::RBRACK);
    _ctx->stop = _input->LT(-1);
    setState(626);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ArrayTypeContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleArrayType);
        setState(621);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(622);
        match(PrystParser::LBRACK);
        setState(623);
        match(PrystParser::RBRACK); 
      }
      setState(628);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- MapTypeContext ------------------------------------------------------------------

PrystParser::MapTypeContext::MapTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::MapTypeContext::MAP() {
  return getToken(PrystParser::MAP, 0);
}

tree::TerminalNode* PrystParser::MapTypeContext::LT() {
  return getToken(PrystParser::LT, 0);
}

PrystParser::KeyTypeContext* PrystParser::MapTypeContext::keyType() {
  return getRuleContext<PrystParser::KeyTypeContext>(0);
}

tree::TerminalNode* PrystParser::MapTypeContext::COMMA() {
  return getToken(PrystParser::COMMA, 0);
}

PrystParser::TypeContext* PrystParser::MapTypeContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::MapTypeContext::GT() {
  return getToken(PrystParser::GT, 0);
}


size_t PrystParser::MapTypeContext::getRuleIndex() const {
  return PrystParser::RuleMapType;
}


std::any PrystParser::MapTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMapType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::MapTypeContext* PrystParser::mapType() {
  MapTypeContext *_localctx = _tracker.createInstance<MapTypeContext>(_ctx, getState());
  enterRule(_localctx, 86, PrystParser::RuleMapType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    match(PrystParser::MAP);
    setState(630);
    match(PrystParser::LT);
    setState(631);
    keyType();
    setState(632);
    match(PrystParser::COMMA);
    setState(633);
    type();
    setState(634);
    match(PrystParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyTypeContext ------------------------------------------------------------------

PrystParser::KeyTypeContext::KeyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::KeyTypeContext::STR() {
  return getToken(PrystParser::STR, 0);
}

tree::TerminalNode* PrystParser::KeyTypeContext::INT() {
  return getToken(PrystParser::INT, 0);
}


size_t PrystParser::KeyTypeContext::getRuleIndex() const {
  return PrystParser::RuleKeyType;
}


std::any PrystParser::KeyTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitKeyType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::KeyTypeContext* PrystParser::keyType() {
  KeyTypeContext *_localctx = _tracker.createInstance<KeyTypeContext>(_ctx, getState());
  enterRule(_localctx, 88, PrystParser::RuleKeyType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(636);
    _la = _input->LA(1);
    if (!(_la == PrystParser::INT

    || _la == PrystParser::STR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

PrystParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::FunctionTypeContext::FN() {
  return getToken(PrystParser::FN, 0);
}

tree::TerminalNode* PrystParser::FunctionTypeContext::LT() {
  return getToken(PrystParser::LT, 0);
}

PrystParser::ReturnTypeContext* PrystParser::FunctionTypeContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

tree::TerminalNode* PrystParser::FunctionTypeContext::GT() {
  return getToken(PrystParser::GT, 0);
}

tree::TerminalNode* PrystParser::FunctionTypeContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::FunctionTypeContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::TypeListContext* PrystParser::FunctionTypeContext::typeList() {
  return getRuleContext<PrystParser::TypeListContext>(0);
}


size_t PrystParser::FunctionTypeContext::getRuleIndex() const {
  return PrystParser::RuleFunctionType;
}


std::any PrystParser::FunctionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitFunctionType(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::FunctionTypeContext* PrystParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 90, PrystParser::RuleFunctionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    match(PrystParser::FN);
    setState(639);
    match(PrystParser::LT);
    setState(640);
    returnType();
    setState(641);
    match(PrystParser::GT);
    setState(642);
    match(PrystParser::LPAREN);
    setState(644);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
      setState(643);
      typeList();
    }
    setState(646);
    match(PrystParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeListContext ------------------------------------------------------------------

PrystParser::TypeListContext::TypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::TypeContext *> PrystParser::TypeListContext::type() {
  return getRuleContexts<PrystParser::TypeContext>();
}

PrystParser::TypeContext* PrystParser::TypeListContext::type(size_t i) {
  return getRuleContext<PrystParser::TypeContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::TypeListContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::TypeListContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::TypeListContext::getRuleIndex() const {
  return PrystParser::RuleTypeList;
}


std::any PrystParser::TypeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitTypeList(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::TypeListContext* PrystParser::typeList() {
  TypeListContext *_localctx = _tracker.createInstance<TypeListContext>(_ctx, getState());
  enterRule(_localctx, 92, PrystParser::RuleTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(648);
    type();
    setState(653);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(649);
      match(PrystParser::COMMA);
      setState(650);
      type();
      setState(655);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

PrystParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PrystParser::ExpressionContext::getRuleIndex() const {
  return PrystParser::RuleExpression;
}

void PrystParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AssignmentExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::AssignmentExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::AssignmentExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::AssignmentExprContext::ASSIGN() {
  return getToken(PrystParser::ASSIGN, 0);
}

PrystParser::AssignmentExprContext::AssignmentExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::AssignmentExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- InstanceofExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::InstanceofExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::InstanceofExprContext::INSTANCEOF() {
  return getToken(PrystParser::INSTANCEOF, 0);
}

PrystParser::TypeContext* PrystParser::InstanceofExprContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

PrystParser::InstanceofExprContext::InstanceofExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::InstanceofExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitInstanceofExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CastExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::CastExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::TypeContext* PrystParser::CastExprContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::CastExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::ExpressionContext* PrystParser::CastExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

PrystParser::CastExprContext::CastExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::CastExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitCastExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TypeofExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::TypeofExprContext::TYPEOF() {
  return getToken(PrystParser::TYPEOF, 0);
}

PrystParser::ExpressionContext* PrystParser::TypeofExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

PrystParser::TypeofExprContext::TypeofExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::TypeofExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitTypeofExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AdditiveExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::AdditiveExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::AdditiveExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::AdditiveExprContext::PLUS() {
  return getToken(PrystParser::PLUS, 0);
}

tree::TerminalNode* PrystParser::AdditiveExprContext::MINUS() {
  return getToken(PrystParser::MINUS, 0);
}

PrystParser::AdditiveExprContext::AdditiveExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::AdditiveExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitAdditiveExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ParenExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::ParenExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

PrystParser::ExpressionContext* PrystParser::ParenExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::ParenExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::ParenExprContext::ParenExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ParenExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitParenExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NullableChainContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::NullableChainContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::NullableChainContext::QUESTION_MARK() {
  return getToken(PrystParser::QUESTION_MARK, 0);
}

tree::TerminalNode* PrystParser::NullableChainContext::DOT() {
  return getToken(PrystParser::DOT, 0);
}

tree::TerminalNode* PrystParser::NullableChainContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

PrystParser::NullableChainContext::NullableChainContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NullableChainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNullableChain(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MethodCallExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::MethodCallExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::MethodCallExprContext::DOT() {
  return getToken(PrystParser::DOT, 0);
}

tree::TerminalNode* PrystParser::MethodCallExprContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::MethodCallExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::MethodCallExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::GenericArgsContext* PrystParser::MethodCallExprContext::genericArgs() {
  return getRuleContext<PrystParser::GenericArgsContext>(0);
}

PrystParser::ArgumentsContext* PrystParser::MethodCallExprContext::arguments() {
  return getRuleContext<PrystParser::ArgumentsContext>(0);
}

PrystParser::MethodCallExprContext::MethodCallExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::MethodCallExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMethodCallExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ArrayAccessExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::ArrayAccessExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::ArrayAccessExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::ArrayAccessExprContext::LBRACK() {
  return getTokens(PrystParser::LBRACK);
}

tree::TerminalNode* PrystParser::ArrayAccessExprContext::LBRACK(size_t i) {
  return getToken(PrystParser::LBRACK, i);
}

std::vector<tree::TerminalNode *> PrystParser::ArrayAccessExprContext::RBRACK() {
  return getTokens(PrystParser::RBRACK);
}

tree::TerminalNode* PrystParser::ArrayAccessExprContext::RBRACK(size_t i) {
  return getToken(PrystParser::RBRACK, i);
}

PrystParser::ArrayAccessExprContext::ArrayAccessExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ArrayAccessExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitArrayAccessExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprContext ------------------------------------------------------------------

PrystParser::PrimaryContext* PrystParser::PrimaryExprContext::primary() {
  return getRuleContext<PrystParser::PrimaryContext>(0);
}

PrystParser::PrimaryExprContext::PrimaryExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::PrimaryExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LambdaExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::LambdaExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::LambdaExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

tree::TerminalNode* PrystParser::LambdaExprContext::ARROW() {
  return getToken(PrystParser::ARROW, 0);
}

PrystParser::ReturnTypeContext* PrystParser::LambdaExprContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

PrystParser::BlockContext* PrystParser::LambdaExprContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

PrystParser::ExpressionContext* PrystParser::LambdaExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

PrystParser::LambdaParamsContext* PrystParser::LambdaExprContext::lambdaParams() {
  return getRuleContext<PrystParser::LambdaParamsContext>(0);
}

PrystParser::LambdaExprContext::LambdaExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::LambdaExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitLambdaExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FunctionCallExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::FunctionCallExprContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::FunctionCallExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::FunctionCallExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::ArgumentsContext* PrystParser::FunctionCallExprContext::arguments() {
  return getRuleContext<PrystParser::ArgumentsContext>(0);
}

PrystParser::FunctionCallExprContext::FunctionCallExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::FunctionCallExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitFunctionCallExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MemberAccessExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::MemberAccessExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::MemberAccessExprContext::DOT() {
  return getToken(PrystParser::DOT, 0);
}

tree::TerminalNode* PrystParser::MemberAccessExprContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

PrystParser::MemberAccessExprContext::MemberAccessExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::MemberAccessExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMemberAccessExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PostfixExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::PostfixExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::PostfixExprContext::INC() {
  return getToken(PrystParser::INC, 0);
}

tree::TerminalNode* PrystParser::PostfixExprContext::DEC() {
  return getToken(PrystParser::DEC, 0);
}

PrystParser::PostfixExprContext::PostfixExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::PostfixExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPostfixExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ConditionalExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::ConditionalExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::ConditionalExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::ConditionalExprContext::QUESTION_MARK() {
  return getToken(PrystParser::QUESTION_MARK, 0);
}

tree::TerminalNode* PrystParser::ConditionalExprContext::COLON() {
  return getToken(PrystParser::COLON, 0);
}

PrystParser::ConditionalExprContext::ConditionalExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ConditionalExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitConditionalExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LogicalAndExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::LogicalAndExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::LogicalAndExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::LogicalAndExprContext::AND() {
  return getToken(PrystParser::AND, 0);
}

PrystParser::LogicalAndExprContext::LogicalAndExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::LogicalAndExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitLogicalAndExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NullCoalesceExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::NullCoalesceExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::NullCoalesceExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::NullCoalesceExprContext::NULL_COALESCE() {
  return getToken(PrystParser::NULL_COALESCE, 0);
}

PrystParser::NullCoalesceExprContext::NullCoalesceExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NullCoalesceExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNullCoalesceExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RelationalExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::RelationalExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::RelationalExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::RelationalExprContext::LT() {
  return getToken(PrystParser::LT, 0);
}

tree::TerminalNode* PrystParser::RelationalExprContext::GT() {
  return getToken(PrystParser::GT, 0);
}

tree::TerminalNode* PrystParser::RelationalExprContext::LE() {
  return getToken(PrystParser::LE, 0);
}

tree::TerminalNode* PrystParser::RelationalExprContext::GE() {
  return getToken(PrystParser::GE, 0);
}

PrystParser::RelationalExprContext::RelationalExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::RelationalExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitRelationalExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NullableMethodCallExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::NullableMethodCallExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::NullableMethodCallExprContext::QUESTION_MARK() {
  return getToken(PrystParser::QUESTION_MARK, 0);
}

tree::TerminalNode* PrystParser::NullableMethodCallExprContext::DOT() {
  return getToken(PrystParser::DOT, 0);
}

tree::TerminalNode* PrystParser::NullableMethodCallExprContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::NullableMethodCallExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::NullableMethodCallExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::GenericArgsContext* PrystParser::NullableMethodCallExprContext::genericArgs() {
  return getRuleContext<PrystParser::GenericArgsContext>(0);
}

PrystParser::ArgumentsContext* PrystParser::NullableMethodCallExprContext::arguments() {
  return getRuleContext<PrystParser::ArgumentsContext>(0);
}

PrystParser::NullableMethodCallExprContext::NullableMethodCallExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NullableMethodCallExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNullableMethodCallExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LogicalOrExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::LogicalOrExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::LogicalOrExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::LogicalOrExprContext::OR() {
  return getToken(PrystParser::OR, 0);
}

PrystParser::LogicalOrExprContext::LogicalOrExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::LogicalOrExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitLogicalOrExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrefixExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::PrefixExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::PrefixExprContext::NOT() {
  return getToken(PrystParser::NOT, 0);
}

tree::TerminalNode* PrystParser::PrefixExprContext::MINUS() {
  return getToken(PrystParser::MINUS, 0);
}

tree::TerminalNode* PrystParser::PrefixExprContext::INC() {
  return getToken(PrystParser::INC, 0);
}

tree::TerminalNode* PrystParser::PrefixExprContext::DEC() {
  return getToken(PrystParser::DEC, 0);
}

PrystParser::PrefixExprContext::PrefixExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::PrefixExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPrefixExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ConstructorExprContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::ConstructorExprContext::NEW() {
  return getToken(PrystParser::NEW, 0);
}

PrystParser::QualifiedTypeContext* PrystParser::ConstructorExprContext::qualifiedType() {
  return getRuleContext<PrystParser::QualifiedTypeContext>(0);
}

tree::TerminalNode* PrystParser::ConstructorExprContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ConstructorExprContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::GenericArgsContext* PrystParser::ConstructorExprContext::genericArgs() {
  return getRuleContext<PrystParser::GenericArgsContext>(0);
}

PrystParser::ArgumentsContext* PrystParser::ConstructorExprContext::arguments() {
  return getRuleContext<PrystParser::ArgumentsContext>(0);
}

PrystParser::ConstructorExprContext::ConstructorExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ConstructorExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitConstructorExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NonNullAssertExprContext ------------------------------------------------------------------

PrystParser::ExpressionContext* PrystParser::NonNullAssertExprContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::NonNullAssertExprContext::NOT() {
  return getToken(PrystParser::NOT, 0);
}

PrystParser::NonNullAssertExprContext::NonNullAssertExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NonNullAssertExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNonNullAssertExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MultiplicativeExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::MultiplicativeExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::MultiplicativeExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::MultiplicativeExprContext::STAR() {
  return getToken(PrystParser::STAR, 0);
}

tree::TerminalNode* PrystParser::MultiplicativeExprContext::SLASH() {
  return getToken(PrystParser::SLASH, 0);
}

tree::TerminalNode* PrystParser::MultiplicativeExprContext::PERCENT() {
  return getToken(PrystParser::PERCENT, 0);
}

PrystParser::MultiplicativeExprContext::MultiplicativeExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::MultiplicativeExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMultiplicativeExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EqualityExprContext ------------------------------------------------------------------

std::vector<PrystParser::ExpressionContext *> PrystParser::EqualityExprContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::EqualityExprContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::EqualityExprContext::EQ() {
  return getToken(PrystParser::EQ, 0);
}

tree::TerminalNode* PrystParser::EqualityExprContext::NEQ() {
  return getToken(PrystParser::NEQ, 0);
}

PrystParser::EqualityExprContext::EqualityExprContext(ExpressionContext *ctx) { copyFrom(ctx); }


std::any PrystParser::EqualityExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitEqualityExpr(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ExpressionContext* PrystParser::expression() {
   return expression(0);
}

PrystParser::ExpressionContext* PrystParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PrystParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  PrystParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 94;
  enterRecursionRule(_localctx, 94, PrystParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(700);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PrimaryExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(657);
      primary();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ConstructorExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(658);
      match(PrystParser::NEW);
      setState(659);
      qualifiedType();
      setState(661);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::LT) {
        setState(660);
        genericArgs();
      }
      setState(663);
      match(PrystParser::LPAREN);
      setState(665);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(664);
        arguments();
      }
      setState(667);
      match(PrystParser::RPAREN);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<FunctionCallExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(669);
      match(PrystParser::IDENTIFIER);
      setState(670);
      match(PrystParser::LPAREN);
      setState(672);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(671);
        arguments();
      }
      setState(674);
      match(PrystParser::RPAREN);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<TypeofExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(675);
      match(PrystParser::TYPEOF);
      setState(676);
      expression(21);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<CastExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(677);
      match(PrystParser::LPAREN);
      setState(678);
      type();
      setState(679);
      match(PrystParser::RPAREN);
      setState(680);
      expression(15);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<ParenExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(682);
      match(PrystParser::LPAREN);
      setState(683);
      expression(0);
      setState(684);
      match(PrystParser::RPAREN);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<PrefixExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(686);
      antlrcpp::downCast<PrefixExprContext *>(_localctx)->prefix = _input->LT(1);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619628296437760) != 0))) {
        antlrcpp::downCast<PrefixExprContext *>(_localctx)->prefix = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(687);
      expression(12);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<LambdaExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(688);
      match(PrystParser::LPAREN);
      setState(690);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
        setState(689);
        lambdaParams();
      }
      setState(692);
      match(PrystParser::RPAREN);
      setState(693);
      match(PrystParser::ARROW);
      setState(698);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
      case 1: {
        setState(694);
        returnType();
        setState(695);
        block();
        break;
      }

      case 2: {
        setState(697);
        expression(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(780);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(778);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<MultiplicativeExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(702);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(703);
          antlrcpp::downCast<MultiplicativeExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 123145302310912) != 0))) {
            antlrcpp::downCast<MultiplicativeExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(704);
          expression(11);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<AdditiveExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(705);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(706);
          antlrcpp::downCast<AdditiveExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == PrystParser::PLUS

          || _la == PrystParser::MINUS)) {
            antlrcpp::downCast<AdditiveExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(707);
          expression(10);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<RelationalExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(708);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(709);
          antlrcpp::downCast<RelationalExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 16888498602639360) != 0))) {
            antlrcpp::downCast<RelationalExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(710);
          expression(9);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<EqualityExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(711);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(712);
          antlrcpp::downCast<EqualityExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == PrystParser::EQ

          || _la == PrystParser::NEQ)) {
            antlrcpp::downCast<EqualityExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(713);
          expression(8);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<NullCoalesceExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(714);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(715);
          match(PrystParser::NULL_COALESCE);
          setState(716);
          expression(7);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<LogicalAndExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(717);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(718);
          match(PrystParser::AND);
          setState(719);
          expression(6);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<LogicalOrExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(720);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(721);
          match(PrystParser::OR);
          setState(722);
          expression(5);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<ConditionalExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(723);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(724);
          match(PrystParser::QUESTION_MARK);
          setState(725);
          expression(0);
          setState(726);
          match(PrystParser::COLON);
          setState(727);
          expression(3);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<AssignmentExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(729);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(730);
          match(PrystParser::ASSIGN);
          setState(731);
          expression(2);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<InstanceofExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(732);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(733);
          match(PrystParser::INSTANCEOF);
          setState(734);
          type();
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<MemberAccessExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(735);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(736);
          match(PrystParser::DOT);
          setState(737);
          match(PrystParser::IDENTIFIER);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<NullableChainContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(738);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(739);
          match(PrystParser::QUESTION_MARK);
          setState(740);
          match(PrystParser::DOT);
          setState(741);
          match(PrystParser::IDENTIFIER);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<MethodCallExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(742);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(743);
          match(PrystParser::DOT);
          setState(744);
          match(PrystParser::IDENTIFIER);
          setState(746);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PrystParser::LT) {
            setState(745);
            genericArgs();
          }
          setState(748);
          match(PrystParser::LPAREN);
          setState(750);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 7189) != 0)) {
            setState(749);
            arguments();
          }
          setState(752);
          match(PrystParser::RPAREN);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<NullableMethodCallExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(753);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(754);
          match(PrystParser::QUESTION_MARK);
          setState(755);
          match(PrystParser::DOT);
          setState(756);
          match(PrystParser::IDENTIFIER);
          setState(758);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PrystParser::LT) {
            setState(757);
            genericArgs();
          }
          setState(760);
          match(PrystParser::LPAREN);
          setState(762);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & 7189) != 0)) {
            setState(761);
            arguments();
          }
          setState(764);
          match(PrystParser::RPAREN);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<ArrayAccessExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(765);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(770); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(766);
                    match(PrystParser::LBRACK);
                    setState(767);
                    expression(0);
                    setState(768);
                    match(PrystParser::RBRACK);
                    break;
                  }

            default:
              throw NoViableAltException(this);
            }
            setState(772); 
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
          } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<NonNullAssertExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(774);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(775);
          match(PrystParser::NOT);
          break;
        }

        case 17: {
          auto newContext = _tracker.createInstance<PostfixExprContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpression);
          setState(776);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(777);
          antlrcpp::downCast<PostfixExprContext *>(_localctx)->postfix = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == PrystParser::INC

          || _la == PrystParser::DEC)) {
            antlrcpp::downCast<PostfixExprContext *>(_localctx)->postfix = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(782);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

PrystParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::PrimaryContext::THIS() {
  return getToken(PrystParser::THIS, 0);
}

tree::TerminalNode* PrystParser::PrimaryContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::PrimaryContext::INTEGER() {
  return getToken(PrystParser::INTEGER, 0);
}

tree::TerminalNode* PrystParser::PrimaryContext::FLOAT_LITERAL() {
  return getToken(PrystParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* PrystParser::PrimaryContext::STRING() {
  return getToken(PrystParser::STRING, 0);
}

PrystParser::StringInterpolationContext* PrystParser::PrimaryContext::stringInterpolation() {
  return getRuleContext<PrystParser::StringInterpolationContext>(0);
}

tree::TerminalNode* PrystParser::PrimaryContext::BOOLEAN() {
  return getToken(PrystParser::BOOLEAN, 0);
}

tree::TerminalNode* PrystParser::PrimaryContext::NULL_LIT() {
  return getToken(PrystParser::NULL_LIT, 0);
}

PrystParser::ArrayLiteralContext* PrystParser::PrimaryContext::arrayLiteral() {
  return getRuleContext<PrystParser::ArrayLiteralContext>(0);
}

PrystParser::MapLiteralContext* PrystParser::PrimaryContext::mapLiteral() {
  return getRuleContext<PrystParser::MapLiteralContext>(0);
}


size_t PrystParser::PrimaryContext::getRuleIndex() const {
  return PrystParser::RulePrimary;
}


std::any PrystParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitPrimary(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::PrimaryContext* PrystParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 96, PrystParser::RulePrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(793);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PrystParser::THIS: {
        enterOuterAlt(_localctx, 1);
        setState(783);
        match(PrystParser::THIS);
        break;
      }

      case PrystParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(784);
        match(PrystParser::IDENTIFIER);
        break;
      }

      case PrystParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(785);
        match(PrystParser::INTEGER);
        break;
      }

      case PrystParser::FLOAT_LITERAL: {
        enterOuterAlt(_localctx, 4);
        setState(786);
        match(PrystParser::FLOAT_LITERAL);
        break;
      }

      case PrystParser::STRING: {
        enterOuterAlt(_localctx, 5);
        setState(787);
        match(PrystParser::STRING);
        break;
      }

      case PrystParser::STRING_START: {
        enterOuterAlt(_localctx, 6);
        setState(788);
        stringInterpolation();
        break;
      }

      case PrystParser::BOOLEAN: {
        enterOuterAlt(_localctx, 7);
        setState(789);
        match(PrystParser::BOOLEAN);
        break;
      }

      case PrystParser::NULL_LIT: {
        enterOuterAlt(_localctx, 8);
        setState(790);
        match(PrystParser::NULL_LIT);
        break;
      }

      case PrystParser::LBRACK: {
        enterOuterAlt(_localctx, 9);
        setState(791);
        arrayLiteral();
        break;
      }

      case PrystParser::LBRACE: {
        enterOuterAlt(_localctx, 10);
        setState(792);
        mapLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringInterpolationContext ------------------------------------------------------------------

PrystParser::StringInterpolationContext::StringInterpolationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::StringInterpolationContext::STRING_START() {
  return getToken(PrystParser::STRING_START, 0);
}

std::vector<PrystParser::ExpressionContext *> PrystParser::StringInterpolationContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::StringInterpolationContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::StringInterpolationContext::STRING_END() {
  return getToken(PrystParser::STRING_END, 0);
}

std::vector<tree::TerminalNode *> PrystParser::StringInterpolationContext::STRING_MIDDLE() {
  return getTokens(PrystParser::STRING_MIDDLE);
}

tree::TerminalNode* PrystParser::StringInterpolationContext::STRING_MIDDLE(size_t i) {
  return getToken(PrystParser::STRING_MIDDLE, i);
}


size_t PrystParser::StringInterpolationContext::getRuleIndex() const {
  return PrystParser::RuleStringInterpolation;
}


std::any PrystParser::StringInterpolationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitStringInterpolation(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::StringInterpolationContext* PrystParser::stringInterpolation() {
  StringInterpolationContext *_localctx = _tracker.createInstance<StringInterpolationContext>(_ctx, getState());
  enterRule(_localctx, 98, PrystParser::RuleStringInterpolation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    match(PrystParser::STRING_START);
    setState(796);
    expression(0);
    setState(801);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::STRING_MIDDLE) {
      setState(797);
      match(PrystParser::STRING_MIDDLE);
      setState(798);
      expression(0);
      setState(803);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(804);
    match(PrystParser::STRING_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainedCallContext ------------------------------------------------------------------

PrystParser::ChainedCallContext::ChainedCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::ChainedCallContext::DOT() {
  return getToken(PrystParser::DOT, 0);
}

tree::TerminalNode* PrystParser::ChainedCallContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ChainedCallContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ChainedCallContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::ArgumentsContext* PrystParser::ChainedCallContext::arguments() {
  return getRuleContext<PrystParser::ArgumentsContext>(0);
}

tree::TerminalNode* PrystParser::ChainedCallContext::QUESTION_MARK() {
  return getToken(PrystParser::QUESTION_MARK, 0);
}


size_t PrystParser::ChainedCallContext::getRuleIndex() const {
  return PrystParser::RuleChainedCall;
}


std::any PrystParser::ChainedCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitChainedCall(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ChainedCallContext* PrystParser::chainedCall() {
  ChainedCallContext *_localctx = _tracker.createInstance<ChainedCallContext>(_ctx, getState());
  enterRule(_localctx, 100, PrystParser::RuleChainedCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(826);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(806);
      match(PrystParser::DOT);
      setState(807);
      match(PrystParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(808);
      match(PrystParser::DOT);
      setState(809);
      match(PrystParser::IDENTIFIER);
      setState(810);
      match(PrystParser::LPAREN);
      setState(812);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(811);
        arguments();
      }
      setState(814);
      match(PrystParser::RPAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(815);
      match(PrystParser::QUESTION_MARK);
      setState(816);
      match(PrystParser::DOT);
      setState(817);
      match(PrystParser::IDENTIFIER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(818);
      match(PrystParser::QUESTION_MARK);
      setState(819);
      match(PrystParser::DOT);
      setState(820);
      match(PrystParser::IDENTIFIER);
      setState(821);
      match(PrystParser::LPAREN);
      setState(823);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4539619437170393074) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 7189) != 0)) {
        setState(822);
        arguments();
      }
      setState(825);
      match(PrystParser::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

PrystParser::StringLiteralContext::StringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::StringLiteralContext::STRING() {
  return getToken(PrystParser::STRING, 0);
}


size_t PrystParser::StringLiteralContext::getRuleIndex() const {
  return PrystParser::RuleStringLiteral;
}


std::any PrystParser::StringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitStringLiteral(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::StringLiteralContext* PrystParser::stringLiteral() {
  StringLiteralContext *_localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 102, PrystParser::RuleStringLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(PrystParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaParamsContext ------------------------------------------------------------------

PrystParser::LambdaParamsContext::LambdaParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::TypeContext *> PrystParser::LambdaParamsContext::type() {
  return getRuleContexts<PrystParser::TypeContext>();
}

PrystParser::TypeContext* PrystParser::LambdaParamsContext::type(size_t i) {
  return getRuleContext<PrystParser::TypeContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::LambdaParamsContext::IDENTIFIER() {
  return getTokens(PrystParser::IDENTIFIER);
}

tree::TerminalNode* PrystParser::LambdaParamsContext::IDENTIFIER(size_t i) {
  return getToken(PrystParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> PrystParser::LambdaParamsContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::LambdaParamsContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::LambdaParamsContext::getRuleIndex() const {
  return PrystParser::RuleLambdaParams;
}


std::any PrystParser::LambdaParamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitLambdaParams(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::LambdaParamsContext* PrystParser::lambdaParams() {
  LambdaParamsContext *_localctx = _tracker.createInstance<LambdaParamsContext>(_ctx, getState());
  enterRule(_localctx, 104, PrystParser::RuleLambdaParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(830);
    type();
    setState(831);
    match(PrystParser::IDENTIFIER);
    setState(838);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(832);
      match(PrystParser::COMMA);
      setState(833);
      type();
      setState(834);
      match(PrystParser::IDENTIFIER);
      setState(840);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

PrystParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PrystParser::ExpressionContext *> PrystParser::ArgumentsContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::ArgumentsContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> PrystParser::ArgumentsContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::ArgumentsContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}


size_t PrystParser::ArgumentsContext::getRuleIndex() const {
  return PrystParser::RuleArguments;
}


std::any PrystParser::ArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::ArgumentsContext* PrystParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 106, PrystParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(841);
    expression(0);
    setState(846);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PrystParser::COMMA) {
      setState(842);
      match(PrystParser::COMMA);
      setState(843);
      expression(0);
      setState(848);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

PrystParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PrystParser::ArrayLiteralContext::getRuleIndex() const {
  return PrystParser::RuleArrayLiteral;
}

void PrystParser::ArrayLiteralContext::copyFrom(ArrayLiteralContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NonEmptyArrayLiteralContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::NonEmptyArrayLiteralContext::LBRACK() {
  return getToken(PrystParser::LBRACK, 0);
}

std::vector<PrystParser::ExpressionContext *> PrystParser::NonEmptyArrayLiteralContext::expression() {
  return getRuleContexts<PrystParser::ExpressionContext>();
}

PrystParser::ExpressionContext* PrystParser::NonEmptyArrayLiteralContext::expression(size_t i) {
  return getRuleContext<PrystParser::ExpressionContext>(i);
}

tree::TerminalNode* PrystParser::NonEmptyArrayLiteralContext::RBRACK() {
  return getToken(PrystParser::RBRACK, 0);
}

std::vector<tree::TerminalNode *> PrystParser::NonEmptyArrayLiteralContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::NonEmptyArrayLiteralContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}

PrystParser::NonEmptyArrayLiteralContext::NonEmptyArrayLiteralContext(ArrayLiteralContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NonEmptyArrayLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNonEmptyArrayLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EmptyArrayLiteralContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::EmptyArrayLiteralContext::LBRACK() {
  return getToken(PrystParser::LBRACK, 0);
}

tree::TerminalNode* PrystParser::EmptyArrayLiteralContext::RBRACK() {
  return getToken(PrystParser::RBRACK, 0);
}

PrystParser::EmptyArrayLiteralContext::EmptyArrayLiteralContext(ArrayLiteralContext *ctx) { copyFrom(ctx); }


std::any PrystParser::EmptyArrayLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitEmptyArrayLiteral(this);
  else
    return visitor->visitChildren(this);
}
PrystParser::ArrayLiteralContext* PrystParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 108, PrystParser::RuleArrayLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(865);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PrystParser::EmptyArrayLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(849);
      match(PrystParser::LBRACK);
      setState(850);
      match(PrystParser::RBRACK);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PrystParser::NonEmptyArrayLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(851);
      match(PrystParser::LBRACK);
      setState(852);
      expression(0);
      setState(857);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(853);
          match(PrystParser::COMMA);
          setState(854);
          expression(0); 
        }
        setState(859);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
      }
      setState(861);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::COMMA) {
        setState(860);
        match(PrystParser::COMMA);
      }
      setState(863);
      match(PrystParser::RBRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapLiteralContext ------------------------------------------------------------------

PrystParser::MapLiteralContext::MapLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PrystParser::MapLiteralContext::getRuleIndex() const {
  return PrystParser::RuleMapLiteral;
}

void PrystParser::MapLiteralContext::copyFrom(MapLiteralContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NonEmptyMapLiteralContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::NonEmptyMapLiteralContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

std::vector<PrystParser::MapEntryContext *> PrystParser::NonEmptyMapLiteralContext::mapEntry() {
  return getRuleContexts<PrystParser::MapEntryContext>();
}

PrystParser::MapEntryContext* PrystParser::NonEmptyMapLiteralContext::mapEntry(size_t i) {
  return getRuleContext<PrystParser::MapEntryContext>(i);
}

tree::TerminalNode* PrystParser::NonEmptyMapLiteralContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> PrystParser::NonEmptyMapLiteralContext::COMMA() {
  return getTokens(PrystParser::COMMA);
}

tree::TerminalNode* PrystParser::NonEmptyMapLiteralContext::COMMA(size_t i) {
  return getToken(PrystParser::COMMA, i);
}

PrystParser::NonEmptyMapLiteralContext::NonEmptyMapLiteralContext(MapLiteralContext *ctx) { copyFrom(ctx); }


std::any PrystParser::NonEmptyMapLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitNonEmptyMapLiteral(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EmptyMapLiteralContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::EmptyMapLiteralContext::LBRACE() {
  return getToken(PrystParser::LBRACE, 0);
}

tree::TerminalNode* PrystParser::EmptyMapLiteralContext::RBRACE() {
  return getToken(PrystParser::RBRACE, 0);
}

PrystParser::EmptyMapLiteralContext::EmptyMapLiteralContext(MapLiteralContext *ctx) { copyFrom(ctx); }


std::any PrystParser::EmptyMapLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitEmptyMapLiteral(this);
  else
    return visitor->visitChildren(this);
}
PrystParser::MapLiteralContext* PrystParser::mapLiteral() {
  MapLiteralContext *_localctx = _tracker.createInstance<MapLiteralContext>(_ctx, getState());
  enterRule(_localctx, 110, PrystParser::RuleMapLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(883);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PrystParser::EmptyMapLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(867);
      match(PrystParser::LBRACE);
      setState(868);
      match(PrystParser::RBRACE);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PrystParser::NonEmptyMapLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(869);
      match(PrystParser::LBRACE);
      setState(870);
      mapEntry();
      setState(875);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(871);
          match(PrystParser::COMMA);
          setState(872);
          mapEntry(); 
        }
        setState(877);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
      }
      setState(879);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PrystParser::COMMA) {
        setState(878);
        match(PrystParser::COMMA);
      }
      setState(881);
      match(PrystParser::RBRACE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapEntryContext ------------------------------------------------------------------

PrystParser::MapEntryContext::MapEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::MapEntryContext::COLON() {
  return getToken(PrystParser::COLON, 0);
}

PrystParser::ExpressionContext* PrystParser::MapEntryContext::expression() {
  return getRuleContext<PrystParser::ExpressionContext>(0);
}

tree::TerminalNode* PrystParser::MapEntryContext::STRING() {
  return getToken(PrystParser::STRING, 0);
}

tree::TerminalNode* PrystParser::MapEntryContext::INTEGER() {
  return getToken(PrystParser::INTEGER, 0);
}


size_t PrystParser::MapEntryContext::getRuleIndex() const {
  return PrystParser::RuleMapEntry;
}


std::any PrystParser::MapEntryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMapEntry(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::MapEntryContext* PrystParser::mapEntry() {
  MapEntryContext *_localctx = _tracker.createInstance<MapEntryContext>(_ctx, getState());
  enterRule(_localctx, 112, PrystParser::RuleMapEntry);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(885);
    _la = _input->LA(1);
    if (!(_la == PrystParser::INTEGER || _la == PrystParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(886);
    match(PrystParser::COLON);
    setState(887);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapKeyContext ------------------------------------------------------------------

PrystParser::MapKeyContext::MapKeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PrystParser::MapKeyContext::STRING() {
  return getToken(PrystParser::STRING, 0);
}

tree::TerminalNode* PrystParser::MapKeyContext::INTEGER() {
  return getToken(PrystParser::INTEGER, 0);
}


size_t PrystParser::MapKeyContext::getRuleIndex() const {
  return PrystParser::RuleMapKey;
}


std::any PrystParser::MapKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitMapKey(this);
  else
    return visitor->visitChildren(this);
}

PrystParser::MapKeyContext* PrystParser::mapKey() {
  MapKeyContext *_localctx = _tracker.createInstance<MapKeyContext>(_ctx, getState());
  enterRule(_localctx, 114, PrystParser::RuleMapKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    _la = _input->LA(1);
    if (!(_la == PrystParser::INTEGER || _la == PrystParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorMemberContext ------------------------------------------------------------------

PrystParser::ErrorMemberContext::ErrorMemberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PrystParser::ErrorMemberContext::getRuleIndex() const {
  return PrystParser::RuleErrorMember;
}

void PrystParser::ErrorMemberContext::copyFrom(ErrorMemberContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorFieldContext ------------------------------------------------------------------

PrystParser::TypeContext* PrystParser::ErrorFieldContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::ErrorFieldContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ErrorFieldContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

PrystParser::ErrorFieldContext::ErrorFieldContext(ErrorMemberContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ErrorFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitErrorField(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ErrorMethodContext ------------------------------------------------------------------

PrystParser::ReturnTypeContext* PrystParser::ErrorMethodContext::returnType() {
  return getRuleContext<PrystParser::ReturnTypeContext>(0);
}

tree::TerminalNode* PrystParser::ErrorMethodContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ErrorMethodContext::LPAREN() {
  return getToken(PrystParser::LPAREN, 0);
}

tree::TerminalNode* PrystParser::ErrorMethodContext::RPAREN() {
  return getToken(PrystParser::RPAREN, 0);
}

PrystParser::BlockContext* PrystParser::ErrorMethodContext::block() {
  return getRuleContext<PrystParser::BlockContext>(0);
}

PrystParser::ParametersContext* PrystParser::ErrorMethodContext::parameters() {
  return getRuleContext<PrystParser::ParametersContext>(0);
}

PrystParser::ErrorMethodContext::ErrorMethodContext(ErrorMemberContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ErrorMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitErrorMethod(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ErrorChainFieldContext ------------------------------------------------------------------

tree::TerminalNode* PrystParser::ErrorChainFieldContext::CHAIN() {
  return getToken(PrystParser::CHAIN, 0);
}

PrystParser::TypeContext* PrystParser::ErrorChainFieldContext::type() {
  return getRuleContext<PrystParser::TypeContext>(0);
}

tree::TerminalNode* PrystParser::ErrorChainFieldContext::IDENTIFIER() {
  return getToken(PrystParser::IDENTIFIER, 0);
}

tree::TerminalNode* PrystParser::ErrorChainFieldContext::SEMICOLON() {
  return getToken(PrystParser::SEMICOLON, 0);
}

PrystParser::ErrorChainFieldContext::ErrorChainFieldContext(ErrorMemberContext *ctx) { copyFrom(ctx); }


std::any PrystParser::ErrorChainFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PrystParserVisitor*>(visitor))
    return parserVisitor->visitErrorChainField(this);
  else
    return visitor->visitChildren(this);
}
PrystParser::ErrorMemberContext* PrystParser::errorMember() {
  ErrorMemberContext *_localctx = _tracker.createInstance<ErrorMemberContext>(_ctx, getState());
  enterRule(_localctx, 116, PrystParser::RuleErrorMember);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(909);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PrystParser::ErrorFieldContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(891);
      type();
      setState(892);
      match(PrystParser::IDENTIFIER);
      setState(893);
      match(PrystParser::SEMICOLON);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PrystParser::ErrorMethodContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(895);
      returnType();
      setState(896);
      match(PrystParser::IDENTIFIER);
      setState(897);
      match(PrystParser::LPAREN);
      setState(899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4294968304) != 0) || _la == PrystParser::IDENTIFIER) {
        setState(898);
        parameters();
      }
      setState(901);
      match(PrystParser::RPAREN);
      setState(902);
      block();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PrystParser::ErrorChainFieldContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(904);
      match(PrystParser::CHAIN);
      setState(905);
      type();
      setState(906);
      match(PrystParser::IDENTIFIER);
      setState(907);
      match(PrystParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool PrystParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 42: return arrayTypeSempred(antlrcpp::downCast<ArrayTypeContext *>(context), predicateIndex);
    case 47: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool PrystParser::arrayTypeSempred(ArrayTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool PrystParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 10);
    case 2: return precpred(_ctx, 9);
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 7);
    case 5: return precpred(_ctx, 6);
    case 6: return precpred(_ctx, 5);
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 3);
    case 9: return precpred(_ctx, 2);
    case 10: return precpred(_ctx, 22);
    case 11: return precpred(_ctx, 20);
    case 12: return precpred(_ctx, 19);
    case 13: return precpred(_ctx, 18);
    case 14: return precpred(_ctx, 17);
    case 15: return precpred(_ctx, 16);
    case 16: return precpred(_ctx, 14);
    case 17: return precpred(_ctx, 11);

  default:
    break;
  }
  return true;
}

void PrystParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  prystparserParserInitialize();
#else
  ::antlr4::internal::call_once(prystparserParserOnceFlag, prystparserParserInitialize);
#endif
}
