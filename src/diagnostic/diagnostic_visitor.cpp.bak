#include "diagnostic_visitor.hpp"
#include "utils/logger.hpp"
#include <sstream>

namespace pryst {

DiagnosticVisitor::DiagnosticVisitor()
    : inLoop(false) {}

std::any DiagnosticVisitor::visitProgram(PrystParser::ProgramContext* ctx) {
    PRYST_DEBUG("Visiting program");
    for (auto decl : ctx->declaration()) {
        visit(decl);
    }
    return std::any();
}

std::any DiagnosticVisitor::visitNamespace(PrystParser::NamespaceContext* ctx) {
    PRYST_DEBUG("Visiting namespace: " + ctx->name->getText());
    currentNamespace.push_back(ctx->name->getText());
    visit(ctx->body);
    currentNamespace.pop_back();
    return std::any();
}

std::any DiagnosticVisitor::visitModule(PrystParser::ModuleContext* ctx) {
    PRYST_DEBUG("Visiting module: " + ctx->name->getText());
    auto prevModule = currentModule;
    currentModule = ctx->name->getText();
    visit(ctx->body);
    currentModule = prevModule;
    return std::any();
}

std::any DiagnosticVisitor::visitImport(PrystParser::ImportContext* ctx) {
    PRYST_DEBUG("Visiting import: " + ctx->path->getText());
    return std::any();
}

std::any DiagnosticVisitor::visitUsingDecl(PrystParser::UsingDeclContext* ctx) {
    PRYST_DEBUG("Visiting using declaration: " + ctx->path->getText());
    return std::any();
}

std::any DiagnosticVisitor::visitFunctionDecl(PrystParser::FunctionDeclContext* ctx) {
    PRYST_DEBUG("Visiting function declaration: " + ctx->name->getText());
    auto prevFunction = currentFunction;
    currentFunction = ctx->name->getText();

    // Check return type if specified
    if (ctx->returnType) {
        visit(ctx->returnType);
    }

    // Check parameter types
    for (auto param : ctx->parameters) {
        visit(param->type());
    }

    visit(ctx->body);
    currentFunction = prevFunction;
    return std::any();
}

std::any DiagnosticVisitor::visitClassDecl(PrystParser::ClassDeclContext* ctx) {
    PRYST_DEBUG("Visiting class declaration: " + ctx->name->getText());
    visit(ctx->body);
    return std::any();
}

std::any DiagnosticVisitor::visitMethodDecl(PrystParser::MethodDeclContext* ctx) {
    PRYST_DEBUG("Visiting method declaration: " + ctx->name->getText());
    auto prevFunction = currentFunction;
    currentFunction = ctx->name->getText();

    // Check return type if specified
    if (ctx->returnType) {
        visit(ctx->returnType);
    }

    // Check parameter types
    for (auto param : ctx->parameters) {
        visit(param->type());
    }

    visit(ctx->body);
    currentFunction = prevFunction;
    return std::any();
}

std::any DiagnosticVisitor::visitVariableDecl(PrystParser::VariableDeclContext* ctx) {
    PRYST_DEBUG("Visiting variable declaration: " + ctx->name->getText());

    // Check type if specified
    if (ctx->type()) {
        visit(ctx->type());
    }

    // Check initializer if present
    if (ctx->initializer) {
        visit(ctx->initializer);
    }

    return std::any();
}

std::any DiagnosticVisitor::visitBlock(PrystParser::BlockContext* ctx) {
    PRYST_DEBUG("Visiting block");
    for (auto stmt : ctx->statement()) {
        visit(stmt);
    }
    return std::any();
}

std::any DiagnosticVisitor::visitIfStmt(PrystParser::IfStmtContext* ctx) {
    PRYST_DEBUG("Visiting if statement");
    visit(ctx->condition);
    visit(ctx->thenBranch);
    if (ctx->elseBranch) {
        visit(ctx->elseBranch);
    }
    return std::any();
}

std::any DiagnosticVisitor::visitWhileStmt(PrystParser::WhileStmtContext* ctx) {
    PRYST_DEBUG("Visiting while statement");
    bool wasInLoop = inLoop;
    inLoop = true;
    visit(ctx->condition);
    visit(ctx->body);
    inLoop = wasInLoop;
    return std::any();
}

std::any DiagnosticVisitor::visitReturnStmt(PrystParser::ReturnStmtContext* ctx) {
    PRYST_DEBUG("Visiting return statement");
    if (!currentFunction.empty()) {
        if (ctx->value) {
            visit(ctx->value);
        }
    } else {
        reportError(ctx, "Return statement outside of function");
    }
    return std::any();
}

std::any DiagnosticVisitor::visitBinary(PrystParser::BinaryContext* ctx) {
    PRYST_DEBUG("Visiting binary expression");
    visit(ctx->left);
    visit(ctx->right);
    return std::any();
}

std::any DiagnosticVisitor::visitUnary(PrystParser::UnaryContext* ctx) {
    PRYST_DEBUG("Visiting unary expression");
    visit(ctx->operand);
    return std::any();
}

std::any DiagnosticVisitor::visitCall(PrystParser::CallContext* ctx) {
    PRYST_DEBUG("Visiting function call: " + ctx->name->getText());
    for (auto arg : ctx->arguments) {
        visit(arg);
    }
    return std::any();
}

std::any DiagnosticVisitor::visitLiteral(PrystParser::LiteralContext* ctx) {
    PRYST_DEBUG("Visiting literal");
    return std::any();
}

std::any DiagnosticVisitor::visitVariable(PrystParser::VariableContext* ctx) {
    PRYST_DEBUG("Visiting variable: " + ctx->name->getText());
    return std::any();
}

std::any DiagnosticVisitor::visitLambda(PrystParser::LambdaContext* ctx) {
    PRYST_DEBUG("Visiting lambda expression");
    auto prevFunction = currentFunction;
    currentFunction = "<lambda>";

    // Check parameter types
    for (auto param : ctx->parameters) {
        visit(param->type());
    }

    // Check return type if specified
    if (ctx->returnType) {
        visit(ctx->returnType);
    }

    visit(ctx->body);
    currentFunction = prevFunction;
    return std::any();
}

std::any DiagnosticVisitor::visitType(PrystParser::TypeContext* ctx) {
    PRYST_DEBUG("Visiting type: " + ctx->getText());
    return std::any();
}

void DiagnosticVisitor::reportError(antlr4::ParserRuleContext* ctx, const std::string& message) {
    std::string location = getLocation(ctx);
    PRYST_ERROR(location + ": " + message);
}

void DiagnosticVisitor::reportWarning(antlr4::ParserRuleContext* ctx, const std::string& message) {
    std::string location = getLocation(ctx);
    PRYST_DEBUG("Warning at " + location + ": " + message);
}

std::string DiagnosticVisitor::getLocation(antlr4::ParserRuleContext* ctx) {
    auto token = ctx->getStart();
    return "line " + std::to_string(token->getLine()) +
           ", column " + std::to_string(token->getCharPositionInLine());
}

} // namespace pryst
