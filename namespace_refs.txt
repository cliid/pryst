size_t LLVMCodegen::getMemberIndex(llvm::StructType* structType, const std::string& memberName) {
    std::string className = structType->getName().str();
            auto superClassType = llvm::StructType::getTypeByName(*context, pair.second);
                } catch (const std::runtime_error&) {
    throw std::runtime_error("Member not found: " + memberName);
void LLVMCodegen::addClassMember(const std::string& className, const std::string& memberName, size_t index) {
LLVMCodegen::LLVMCodegen()
    : context(std::make_unique<llvm::LLVMContext>()),
      module(std::make_unique<llvm::Module>("pryst", *context)),
      builder(std::make_unique<llvm::IRBuilder<>>(*context)),
std::unique_ptr<llvm::Module> LLVMCodegen::generateModule(PrystParser::ProgramContext* programCtx) {
    if (llvm::verifyModule(*module, &llvm::errs())) {
        throw std::runtime_error("Generated LLVM IR is invalid");
    return std::move(module);
llvm::Function* LLVMCodegen::createMainFunction() {
    llvm::FunctionType* mainFuncType = llvm::FunctionType::get(llvm::Type::getInt32Ty(*context), false);
    llvm::Function* mainFunc = llvm::Function::Create(mainFuncType, llvm::Function::ExternalLinkage, "main", module.get());
    llvm::BasicBlock* entryBlock = llvm::BasicBlock::Create(*context, "entry", mainFunc);
    builder->CreateRet(llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 0));
std::any LLVMCodegen::visitProgram(PrystParser::ProgramContext* ctx) {
std::any LLVMCodegen::visitDeclaration(PrystParser::DeclarationContext* ctx) {
std::any LLVMCodegen::visitFunctionDecl(PrystParser::FunctionDeclContext* ctx) {
    if (auto namedFunc = dynamic_cast<PrystParser::NamedFunctionContext*>(ctx)) {
    } else if (auto lambdaFunc = dynamic_cast<PrystParser::LambdaFunctionContext*>(ctx)) {
std::any LLVMCodegen::visitNamedFunction(PrystParser::NamedFunctionContext* ctx) {
    std::string funcName = ctx->IDENTIFIER()->getText();
    llvm::Type* returnType = getLLVMType(ctx->type()->getText());
    std::vector<llvm::Type*> paramTypes;
    std::vector<std::string> paramNames;
    std::vector<TypeInfoPtr> paramTypeInfos;
    auto& registry = TypeRegistry::getInstance();
        throw std::runtime_error("Unknown return type: " + ctx->type()->getText());
                throw std::runtime_error("Unknown parameter type: " + param->type()->getText());
    llvm::FunctionType* funcType = llvm::FunctionType::get(returnType, paramTypes, false);
    llvm::Function* function = llvm::Function::Create(
        funcType, llvm::Function::ExternalLinkage, funcName, module.get());
    auto functionTypeInfo = std::make_shared<pryst::LLVMFunctionTypeInfo>(
    llvm::BasicBlock* bb = llvm::BasicBlock::Create(*context, "entry", function);
    llvm::Function* oldFunction = currentFunction;
            std::string paramName = paramNames[idx++];
            llvm::AllocaInst* alloca = createEntryBlockAlloca(function, paramName, arg.getType());
            builder->CreateRet(llvm::Constant::getNullValue(returnType));
    if (llvm::verifyFunction(*function, &llvm::errs())) {
        throw std::runtime_error("Function verification failed for function: " + funcName);
std::any LLVMCodegen::visitVariableDecl(PrystParser::VariableDeclContext* ctx) {
    std::string varName = ctx->IDENTIFIER()->getText();
    llvm::Type* varType = getLLVMType(ctx->type()->getText());
    llvm::AllocaInst* alloca = createEntryBlockAlloca(currentFunction, varName, varType);
        builder->CreateStore(llvm::Constant::getNullValue(varType), alloca);
std::any LLVMCodegen::visitClassDeclaration(PrystParser::ClassDeclarationContext* ctx) {
    std::string className = ctx->IDENTIFIER(0)->getText();
    std::vector<std::string> inheritanceChain;
    std::string immediateBase;
        std::string currentClass = immediateBase;
        std::reverse(inheritanceChain.begin(), inheritanceChain.end());
    std::vector<llvm::Type*> orderedTypes;
    std::vector<std::string> orderedNames;
    std::unordered_map<std::string, size_t> memberOffsets;
        auto baseType = llvm::StructType::getTypeByName(*context, baseClass);
            throw std::runtime_error("Base class not found: " + baseClass);
        std::vector<std::pair<std::string, size_t>> sortedMembers(baseMembers.begin(), baseMembers.end());
        std::sort(sortedMembers.begin(), sortedMembers.end(),
        auto& registry = TypeRegistry::getInstance();
            throw std::runtime_error("Class type info not found for: " + baseClass);
                throw std::runtime_error("Member type info not found for: " + memberName + " in class " + baseClass);
            if (auto varDecl = dynamic_cast<PrystParser::ClassVariableDeclContext*>(memberCtx)) {
                std::string memberName = varDecl->IDENTIFIER()->getText();
                llvm::Type* memberType = getLLVMType(varDecl->type()->getText());
            } else if (auto funcDecl = dynamic_cast<PrystParser::ClassFunctionDeclContext*>(memberCtx)) {
    llvm::StructType* classType = llvm::StructType::create(*context, orderedTypes, className);
std::any LLVMCodegen::visitClassVariableDecl(PrystParser::ClassVariableDeclContext* ctx) {
    std::string memberName = ctx->IDENTIFIER()->getText();
    llvm::Type* memberType = getLLVMType(ctx->type()->getText());
std::any LLVMCodegen::visitClassFunctionDecl(PrystParser::ClassFunctionDeclContext* ctx) {
    std::string funcName = ctx->IDENTIFIER()->getText();
    llvm::Type* returnType = getLLVMType(ctx->type()->getText());
    std::unordered_map<std::string, llvm::AllocaInst*> oldNamedValues = namedValues;
std::any LLVMCodegen::visitParamList(PrystParser::ParamListContext* ctx) {
std::any LLVMCodegen::visitParam(PrystParser::ParamContext* ctx) {
std::any LLVMCodegen::visitType(PrystParser::TypeContext* ctx) {
std::any LLVMCodegen::visitExprStatement(PrystParser::ExprStatementContext* ctx) {
std::any LLVMCodegen::visitIfStatement(PrystParser::IfStatementContext* ctx) {
    llvm::Value* condValue = lastValue;
    condValue = builder->CreateICmpNE(condValue, llvm::ConstantInt::get(condValue->getType(), 0), "ifcond");
    llvm::Function* function = builder->GetInsertBlock()->getParent();
    llvm::BasicBlock* thenBlock = llvm::BasicBlock::Create(*context, "then", function);
    llvm::BasicBlock* elseBlock = llvm::BasicBlock::Create(*context, "else");
    llvm::BasicBlock* mergeBlock = llvm::BasicBlock::Create(*context, "ifcont");
std::any LLVMCodegen::visitWhileStatement(PrystParser::WhileStatementContext* ctx) {
    llvm::Function* function = builder->GetInsertBlock()->getParent();
    llvm::BasicBlock* condBlock = llvm::BasicBlock::Create(*context, "whilecond", function);
    llvm::BasicBlock* loopBlock = llvm::BasicBlock::Create(*context, "whilebody");
    llvm::BasicBlock* afterBlock = llvm::BasicBlock::Create(*context, "whileend");
    llvm::Value* condValue = lastValue;
    condValue = builder->CreateICmpNE(condValue, llvm::ConstantInt::get(condValue->getType(), 0), "whilecond");
std::any LLVMCodegen::visitForStatement(PrystParser::ForStatementContext* ctx) {
    llvm::Function* function = builder->GetInsertBlock()->getParent();
    llvm::BasicBlock* preHeaderBlock = builder->GetInsertBlock();
    llvm::BasicBlock* loopBlock = llvm::BasicBlock::Create(*context, "forloop", function);
    llvm::BasicBlock* afterBlock = llvm::BasicBlock::Create(*context, "forend");
        llvm::Value* condValue = lastValue;
        condValue = builder->CreateICmpNE(condValue, llvm::ConstantInt::get(condValue->getType(), 0), "forcond");
        llvm::BasicBlock* bodyBlock = llvm::BasicBlock::Create(*context, "forbody", function);
std::any LLVMCodegen::visitReturnStatement(PrystParser::ReturnStatementContext* ctx) {
std::any LLVMCodegen::visitBlockStatement(PrystParser::BlockStatementContext* ctx) {
    std::unordered_map<std::string, llvm::AllocaInst*> oldNamedValues = namedValues;
std::any LLVMCodegen::visitAssignment(PrystParser::AssignmentContext* ctx) {
    std::cerr << "DEBUG: Starting visitAssignment" << std::endl;
    std::cerr << "DEBUG: Assignment context text: " << ctx->getText() << std::endl;
    llvm::Value* varAddress;
        std::cerr << "DEBUG: Handling call.DOT IDENTIFIER assignment" << std::endl;
        llvm::Value* object = lastValue;
            throw std::runtime_error("Object is null in member assignment");
        std::string typeStr;
        llvm::raw_string_ostream rso(typeStr);
        std::cerr << "DEBUG: Initial object type: " << typeStr << std::endl;
        if (auto* loadInst = llvm::dyn_cast<llvm::LoadInst>(object)) {
            std::cerr << "DEBUG: Converting load instruction to pointer operand" << std::endl;
            std::cerr << "DEBUG: After load conversion type: " << typeStr << std::endl;
        auto& registry = TypeRegistry::getInstance();
        if (!typeInfo || typeInfo->getKind() != pryst::TypeInfo::Kind::Class) {
            throw std::runtime_error("Expected class type in member access");
        auto classInfo = std::dynamic_pointer_cast<pryst::LLVMClassTypeInfo>(typeInfo);
            throw std::runtime_error("Failed to get class type info");
        std::string className = classInfo->getClassName();
        std::string memberName = ctx->IDENTIFIER()->getText();
        std::cerr << "DEBUG: Looking for member '" << memberName << "' in class '" << className << "'" << std::endl;
            throw std::runtime_error("Member '" + memberName + "' not found in class '" + className + "' or its base classes");
        std::cerr << "DEBUG: Found member at offset " << memberOffset << std::endl;
        std::vector<llvm::Value*> indices = {
            llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 0),
            llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), memberOffset)
        std::cerr << "DEBUG: Handling simple assignment" << std::endl;
            throw std::runtime_error("Undefined variable: " + ctx->IDENTIFIER()->getText());
    std::cerr << "DEBUG: Visiting expression for assignment" << std::endl;
    llvm::Value* exprValue = lastValue;
        throw std::runtime_error("Invalid expression value in assignment");
    std::cerr << "DEBUG: Assignment completed" << std::endl;
std::any LLVMCodegen::visitLogicOr(PrystParser::LogicOrContext* ctx) {
    llvm::Function* function = builder->GetInsertBlock()->getParent();
        throw std::runtime_error("Invalid function context in logical OR");
    llvm::BasicBlock* lhsBlock = builder->GetInsertBlock();
    llvm::BasicBlock* rhsBlock = llvm::BasicBlock::Create(*context, "lor.rhs", function);
    llvm::BasicBlock* mergeBlock = llvm::BasicBlock::Create(*context, "lor.merge", function);
    llvm::Value* lhsValue = lastValue;
        throw std::runtime_error("Invalid left-hand side in logical OR");
    lhsValue = builder->CreateICmpNE(lhsValue, llvm::ConstantInt::get(lhsValue->getType(), 0), "lor.lhs");
    llvm::Value* rhsValue = lastValue;
        throw std::runtime_error("Invalid right-hand side in logical OR");
    rhsValue = builder->CreateICmpNE(rhsValue, llvm::ConstantInt::get(rhsValue->getType(), 0), "lor.rhs");
    llvm::PHINode* phiNode = builder->CreatePHI(llvm::Type::getInt1Ty(*context), 2, "lor.result");
    phiNode->addIncoming(llvm::ConstantInt::getTrue(*context), lhsBlock);
std::any LLVMCodegen::visitLogicAnd(PrystParser::LogicAndContext* ctx) {
    llvm::Function* function = builder->GetInsertBlock()->getParent();
    llvm::BasicBlock* lhsBlock = builder->GetInsertBlock();
    llvm::BasicBlock* rhsBlock = llvm::BasicBlock::Create(*context, "land.rhs", function);
    llvm::BasicBlock* mergeBlock = llvm::BasicBlock::Create(*context, "land.merge", function);
    llvm::Value* lhsValue = lastValue;
    lhsValue = builder->CreateICmpNE(lhsValue, llvm::ConstantInt::get(lhsValue->getType(), 0), "land.lhs");
    llvm::Value* rhsValue = lastValue;
    rhsValue = builder->CreateICmpNE(rhsValue, llvm::ConstantInt::get(rhsValue->getType(), 0), "land.rhs");
    llvm::PHINode* phiNode = builder->CreatePHI(llvm::Type::getInt1Ty(*context), 2, "land.result");
    phiNode->addIncoming(llvm::ConstantInt::getFalse(*context), lhsBlock);
std::any LLVMCodegen::visitEquality(PrystParser::EqualityContext* ctx) {
    llvm::Value* left = lastValue;
        llvm::Value* right = lastValue;
std::any LLVMCodegen::visitComparison(PrystParser::ComparisonContext* ctx) {
    llvm::Value* left = lastValue;
        llvm::Value* right = lastValue;
std::any LLVMCodegen::visitAddition(PrystParser::AdditionContext* ctx) {
    llvm::Value* left = lastValue;
        llvm::Value* right = lastValue;
std::any LLVMCodegen::visitMultiplication(PrystParser::MultiplicationContext* ctx) {
    llvm::Value* left = lastValue;
        llvm::Value* right = lastValue;
std::any LLVMCodegen::visitUnary(PrystParser::UnaryContext* ctx) {
        llvm::Value* operand = lastValue;
            llvm::Value* one = llvm::ConstantInt::get(operand->getType(), 1);
            throw std::runtime_error("Prefix increment not fully implemented");
            llvm::Value* one = llvm::ConstantInt::get(operand->getType(), 1);
            throw std::runtime_error("Prefix decrement not fully implemented");
std::any LLVMCodegen::visitPostfix(PrystParser::PostfixContext* ctx) {
    llvm::Value* operand = lastValue;
            std::vector<llvm::Value*> args;
            if (auto* func = llvm::dyn_cast<llvm::Function>(operand)) {
                throw std::runtime_error("Called value is not a function");
            std::string memberName = memberSuffix->IDENTIFIER()->getText();
            if (!typeInfo || typeInfo->getKind() != pryst::TypeInfo::Kind::Class) {
                throw std::runtime_error("Expected class type in member access");
            auto classInfo = std::dynamic_pointer_cast<pryst::LLVMClassTypeInfo>(typeInfo);
                throw std::runtime_error("Failed to get LLVM class type info");
                throw std::runtime_error("Member '" + memberName + "' not found");
            std::vector<llvm::Value*> indices = {
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 0),
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), memberOffset)
                throw std::runtime_error("Failed to get member type for: " + memberName);
        llvm::Value* one = llvm::ConstantInt::get(operand->getType(), 1);
        llvm::Value* newValue = builder->CreateAdd(operand, one, "postinctmp");
        if (auto* loadInst = llvm::dyn_cast<llvm::LoadInst>(operand)) {
        llvm::Value* one = llvm::ConstantInt::get(operand->getType(), 1);
        llvm::Value* newValue = builder->CreateSub(operand, one, "postdectmp");
        if (auto* loadInst = llvm::dyn_cast<llvm::LoadInst>(operand)) {
std::any LLVMCodegen::visitCall(PrystParser::CallContext* ctx) {
    std::cerr << "DEBUG: Starting visitCall" << std::endl;
    llvm::Value* callee = lastValue;
            std::cerr << "DEBUG: Handling function call" << std::endl;
            std::vector<llvm::Value*> args;
            if (llvm::Function* functionCallee = llvm::dyn_cast<llvm::Function>(callee)) {
                std::string functionName = functionCallee->getName().str();
                    llvm::Function* printfFunc = declarePrintf();
                    llvm::Value* formatStr = builder->CreateGlobalString("%s\n");
                if (!typeInfo || typeInfo->getKind() != pryst::TypeInfo::Kind::Function) {
                    throw std::runtime_error("Called value is not a function");
                std::string functionName;
                llvm::FunctionType* funcType = functionTypes[functionName];
                    throw std::runtime_error("Unknown function: " + functionName);
std::any LLVMCodegen::visitPrimary(PrystParser::PrimaryContext* ctx) {
        lastValue = llvm::ConstantInt::getTrue(*context);
        lastValue = llvm::ConstantInt::getFalse(*context);
        lastValue = llvm::ConstantPointerNull::get(llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(*context)));
        std::string numStr = ctx->NUMBER()->getText();
        if (numStr.find('.') != std::string::npos) {
            lastValue = llvm::ConstantFP::get(*context, llvm::APFloat(std::stod(numStr)));
            lastValue = llvm::ConstantInt::get(*context, llvm::APInt(32, std::stoll(numStr), true));
        std::string str = ctx->STRING()->getText();
        std::string name = ctx->IDENTIFIER()->getText();
            throw std::runtime_error("Unknown identifier: " + name);
        throw std::runtime_error("'super' keyword not implemented");
std::any LLVMCodegen::visitNewExpression(PrystParser::NewExpressionContext* ctx) {
    std::string className = ctx->IDENTIFIER()->getText();
    llvm::StructType* classType = llvm::StructType::getTypeByName(*context, className);
        throw std::runtime_error("Unknown class: " + className);
    llvm::Type* classPtrType = llvm::PointerType::getUnqual(classType);
    llvm::Function* mallocFunc = module->getFunction("malloc");
        llvm::FunctionType* mallocType = llvm::FunctionType::get(
            llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(*context)),
            { llvm::Type::getInt64Ty(*context) },
        mallocFunc = llvm::Function::Create(mallocType, llvm::Function::ExternalLinkage, "malloc", module.get());
    llvm::Value* size = llvm::ConstantInt::get(llvm::Type::getInt64Ty(*context),
    llvm::Value* mem = builder->CreateCall(mallocFunc, {size}, "objmem");
    llvm::Value* obj = builder->CreateBitCast(mem, classPtrType, "obj");
    std::vector<std::string> inheritanceChain;
    std::string currentClass = className;
        std::vector<std::pair<std::string, size_t>> sortedMembers(classIt->second.begin(), classIt->second.end());
        std::sort(sortedMembers.begin(), sortedMembers.end(),
        auto classStructType = llvm::StructType::getTypeByName(*context, cls);
            throw std::runtime_error("Class type info not found for: " + cls);
                throw std::runtime_error("Member type info not found: " + memberName);
            llvm::Type* memberType = getLLVMTypeFromTypeInfo(memberTypeInfo);
            std::vector<llvm::Value*> indices = {
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), 0),
                llvm::ConstantInt::get(llvm::Type::getInt32Ty(*context), offset)
            llvm::Value* memberPtr = builder->CreateGEP(classType, obj, indices, "member.ptr");
            builder->CreateStore(llvm::Constant::getNullValue(memberType), memberPtr);
std::any LLVMCodegen::visitArguments(PrystParser::ArgumentsContext* ctx) {
llvm::Type* LLVMCodegen::getLLVMType(const std::string& typeName) {
        return llvm::Type::getInt32Ty(*context);
        return llvm::Type::getDoubleTy(*context);
        return llvm::Type::getInt1Ty(*context);
        return llvm::PointerType::getUnqual(llvm::Type::getInt8Ty(*context));
        llvm::StructType* structType = llvm::StructType::getTypeByName(*context, typeName);
            return llvm::PointerType::getUnqual(structType);  // Use getUnqual for LLVM 20.0.0
            throw std::runtime_error("Unknown type: " + typeName);
llvm::AllocaInst* LLVMCodegen::createEntryBlockAlloca(llvm::Function* function, const std::string& varName, llvm::Type* type) {
    llvm::IRBuilder<> tmpBuilder(&function->getEntryBlock(), function->getEntryBlock().begin());
std::any LLVMCodegen::visitLambdaFunction(PrystParser::LambdaFunctionContext* ctx) {
    std::string funcName = "lambda_" + std::to_string(lambdaCount++);
    llvm::Type* returnType = ctx->type()
        : llvm::Type::getVoidTy(*context);
    std::vector<llvm::Type*> paramTypes;
    std::vector<std::string> paramNames;
    llvm::FunctionType* funcType = llvm::FunctionType::get(returnType, paramTypes, false);
    llvm::Function* function = llvm::Function::Create(
        funcType, llvm::Function::ExternalLinkage, funcName, module.get());
    std::vector<TypeInfoPtr> paramTypeInfos;
    auto functionTypeInfo = std::make_shared<pryst::LLVMFunctionTypeInfo>(
    llvm::BasicBlock* bb = llvm::BasicBlock::Create(*context, "entry", function);
    llvm::Function* oldFunction = currentFunction;
            std::string paramName = paramNames[idx++];
            llvm::AllocaInst* alloca = createEntryBlockAlloca(function, paramName, arg.getType());
            builder->CreateRet(llvm::Constant::getNullValue(returnType));
    if (llvm::verifyFunction(*function, &llvm::errs())) {
        throw std::runtime_error("Function verification failed for lambda function: " + funcName);
